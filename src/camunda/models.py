# generated by datamodel-codegen:
#   filename:  https://start.camunda.com/openapi.json
#   timestamp: 2021-05-18T15:16:24+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Mapping, Optional, Sequence

from pydantic import BaseModel, Field, conint


class ActivityInstanceIncidentDto(BaseModel):
    """
    An activity instance, incident pair.
    """

    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the incident.')
    parent_activity_instance_id: Optional[str] = Field(
        None,
        alias='parentActivityInstanceId',
        description='The activity id in which the incident happened.',
    )


class AtomLink(BaseModel):
    class Config:
        allow_population_by_field_name = True

    rel: Optional[str] = Field(
        None, description='The relation of the link to the object that belogs to.'
    )
    href: Optional[str] = Field(None, description='The url of the link.')
    method: Optional[str] = Field(None, description='The http method.')


class BatchDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the batch.')
    type: Optional[str] = Field(None, description='The type of the batch.')
    total_jobs: Optional[int] = Field(
        None,
        alias='totalJobs',
        description='The total jobs of a batch is the number of batch execution jobs required to complete the batch.',
    )
    jobs_created: Optional[int] = Field(
        None,
        alias='jobsCreated',
        description='The number of batch execution jobs already created by the seed job.',
    )
    batch_jobs_per_seed: Optional[int] = Field(
        None,
        alias='batchJobsPerSeed',
        description='The number of batch execution jobs created per seed job invocation.\nThe batch seed job is invoked until it has created all batch execution jobs required by the batch (see totalJobs property).',
    )
    invocations_per_batch_job: Optional[int] = Field(
        None,
        alias='invocationsPerBatchJob',
        description='Every batch execution job invokes the command executed by the batch invocationsPerBatchJob times.\nE.g., for a process instance migration batch this specifies the number of process instances which are migrated per batch execution job.',
    )
    seed_job_definition_id: Optional[str] = Field(
        None,
        alias='seedJobDefinitionId',
        description='The job definition id for the seed jobs of this batch.',
    )
    monitor_job_definition_id: Optional[str] = Field(
        None,
        alias='monitorJobDefinitionId',
        description='The job definition id for the monitor jobs of this batch.',
    )
    batch_job_definition_id: Optional[str] = Field(
        None,
        alias='batchJobDefinitionId',
        description='The job definition id for the batch execution jobs of this batch.',
    )
    suspended: Optional[bool] = Field(
        None, description='Indicates whether this batch is suspended or not.'
    )
    tenant_id: Optional[str] = Field(
        None, alias='tenantId', description='The tenant id of the batch.'
    )
    create_user_id: Optional[str] = Field(
        None,
        alias='createUserId',
        description='The id of the user that created the batch.',
    )


class CaseDefinitionDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the case definition')
    key: Optional[str] = Field(
        None,
        description='The key of the case definition, i.e., the id of the CMMN 2.0 XML case definition.',
    )
    category: Optional[str] = Field(
        None, description='The category of the case definition.'
    )
    name: Optional[str] = Field(None, description='The name of the case definition.')
    version: Optional[int] = Field(
        None,
        description='The version of the case definition that the engine assigned to it.',
    )
    resource: Optional[str] = Field(
        None, description='The file name of the case definition.'
    )
    deployment_id: Optional[str] = Field(
        None,
        alias='deploymentId',
        description='The deployment id of the case definition.',
    )
    tenant_id: Optional[str] = Field(
        None, alias='tenantId', description='The tenant id of the case definition.'
    )
    history_time_to_live: Optional[conint(ge=0)] = Field(
        None,
        alias='historyTimeToLive',
        description='History time to live value of the case definition.\nIs used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).',
    )


class CountResultDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    count: Optional[int] = Field(None, description='The number of matching instances.')


class DecisionDefinitionDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the decision definition')
    key: Optional[str] = Field(
        None,
        description='The key of the decision definition, i.e., the id of the DMN 1.0 XML decision definition.',
    )
    category: Optional[str] = Field(
        None, description='The category of the decision definition.'
    )
    name: Optional[str] = Field(
        None, description='The name of the decision definition.'
    )
    version: Optional[int] = Field(
        None,
        description='The version of the decision definition that the engine assigned to it.',
    )
    resource: Optional[str] = Field(
        None, description='The file name of the decision definition.'
    )
    deployment_id: Optional[str] = Field(
        None,
        alias='deploymentId',
        description='The deployment id of the decision definition.',
    )
    tenant_id: Optional[str] = Field(
        None, alias='tenantId', description='The tenant id of the decision definition.'
    )
    decision_requirements_definition_id: Optional[str] = Field(
        None,
        alias='decisionRequirementsDefinitionId',
        description='The id of the decision requirements definition this decision definition belongs to.',
    )
    decision_requirements_definition_key: Optional[str] = Field(
        None,
        alias='decisionRequirementsDefinitionKey',
        description='The key of the decision requirements definition this decision definition belongs to.',
    )
    history_time_to_live: Optional[conint(ge=0)] = Field(
        None,
        alias='historyTimeToLive',
        description='History time to live value of the decision definition.\nIs used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).',
    )
    version_tag: Optional[str] = Field(
        None,
        alias='versionTag',
        description='The version tag of the decision definition.',
    )


class DecisionRequirementsDefinitionDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(
        None, description='The id of the decision requirements definition'
    )
    key: Optional[str] = Field(
        None,
        description='The key of the decision requirements definition, i.e., the id of the DMN 1.0 XML decision definition.',
    )
    name: Optional[str] = Field(
        None, description='The name of the decision requirements definition.'
    )
    category: Optional[str] = Field(
        None, description='The category of the decision requirements definition.'
    )
    version: Optional[int] = Field(
        None,
        description='The version of the decision requirements definition that the engine assigned to it.',
    )
    resource: Optional[str] = Field(
        None, description='The file name of the decision requirements definition.'
    )
    deployment_id: Optional[str] = Field(
        None,
        alias='deploymentId',
        description='The deployment id of the decision requirements definition.',
    )
    tenant_id: Optional[str] = Field(
        None,
        alias='tenantId',
        description='The tenant id of the decisionrequirements definition.',
    )


class DeploymentResourceDto(BaseModel):
    """
        A JSON object corresponding to the `Resource` interface in the engine.
    Its properties are as follows:
    """

    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the deployment resource.')
    name: Optional[str] = Field(None, description='The name of the deployment resource')
    deployment_id: Optional[str] = Field(
        None, alias='deploymentId', description='The id of the deployment.'
    )


class EventSubscriptionDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the event subscription.')
    event_type: Optional[str] = Field(
        None, alias='eventType', description='The type of the event subscription.'
    )
    event_name: Optional[str] = Field(
        None,
        alias='eventName',
        description='The name of the event this subscription belongs to as defined in the process model.',
    )
    execution_id: Optional[str] = Field(
        None,
        alias='executionId',
        description='The execution that is subscribed on the referenced event.',
    )
    process_instance_id: Optional[str] = Field(
        None,
        alias='processInstanceId',
        description='The process instance this subscription belongs to.',
    )
    activity_id: Optional[str] = Field(
        None,
        alias='activityId',
        description='The identifier of the activity that this event subscription belongs to.\nThis could for example be the id of a receive task.',
    )
    created_date: Optional[datetime] = Field(
        None,
        alias='createdDate',
        description='The time this event subscription was created.',
    )
    tenant_id: Optional[str] = Field(
        None,
        alias='tenantId',
        description='The id of the tenant this event subscription belongs to.\nCan be `null` if the subscription belongs to no single tenant.',
    )


class EventType(Enum):
    """
    The type of the event subscription.
    """

    message = 'message'
    signal = 'signal'
    compensate = 'compensate'
    conditional = 'conditional'


class SortBy(Enum):
    """
        Sort the results lexicographically by a given criterion.
    Must be used in conjunction with the sortOrder parameter.
    """

    created = 'created'
    tenant_id = 'tenantId'


class SortOrder(Enum):
    """
        Sort the results in a given order. Values may be `asc` for ascending order or `desc` for
    descending order. Must be used in conjunction with the sortBy parameter.
    """

    asc = 'asc'
    desc = 'desc'


class SortingItem(BaseModel):
    class Config:
        allow_population_by_field_name = True

    sort_by: Optional[SortBy] = Field(
        None,
        alias='sortBy',
        description='Sort the results lexicographically by a given criterion.\nMust be used in conjunction with the sortOrder parameter.',
    )
    sort_order: Optional[SortOrder] = Field(
        None,
        alias='sortOrder',
        description='Sort the results in a given order. Values may be `asc` for ascending order or `desc` for\ndescending order. Must be used in conjunction with the sortBy parameter.',
    )


class EventSubscriptionQueryDto(BaseModel):
    """
    A event subscription query which retrieves a list of event subscriptions
    """

    class Config:
        allow_population_by_field_name = True

    event_subscription_id: Optional[str] = Field(
        None,
        alias='eventSubscriptionId',
        description='The id of the event subscription.',
    )
    event_name: Optional[str] = Field(
        None,
        alias='eventName',
        description='The name of the event this subscription belongs to as defined in the process model.',
    )
    event_type: Optional[EventType] = Field(
        None, alias='eventType', description='The type of the event subscription.'
    )
    execution_id: Optional[str] = Field(
        None,
        alias='executionId',
        description='The execution that is subscribed on the referenced event.',
    )
    process_instance_id: Optional[str] = Field(
        None,
        alias='processInstanceId',
        description='The process instance this subscription belongs to.',
    )
    activity_id: Optional[str] = Field(
        None,
        alias='activityId',
        description='The identifier of the activity that this event subscription belongs to.\nThis could for example be the id of a receive task.',
    )
    tenant_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='tenantIdIn',
        description='Filter by a comma-separated list of tenant ids.\nOnly select subscriptions that belong to one of the given tenant ids.',
    )
    without_tenant_id: Optional[bool] = Field(
        None,
        alias='withoutTenantId',
        description='Only select subscriptions which have no tenant id.\nValue may only be `true`, as `false` is the default behavior.',
    )
    include_event_subscriptions_without_tenant_id: Optional[bool] = Field(
        None,
        alias='includeEventSubscriptionsWithoutTenantId',
        description='Select event subscriptions which have no tenant id.\nCan be used in combination with tenantIdIn parameter.\nValue may only be `true`, as `false` is the default behavior.',
    )
    sorting: Optional[Sequence[SortingItem]] = Field(
        None, description='Apply sorting of the result'
    )


class ExceptionDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    type: Optional[str] = Field(
        None, description='An exception class indicating the occurred error.'
    )
    message: Optional[str] = Field(None, description='A detailed message of the error.')


class ExecutionDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the Execution.')
    process_instance_id: Optional[str] = Field(
        None,
        alias='processInstanceId',
        description='The id of the root of the execution tree representing the process instance.',
    )
    ended: Optional[bool] = Field(
        None, description='Indicates if the execution is ended.'
    )
    tenant_id: Optional[str] = Field(
        None,
        alias='tenantId',
        description='The id of the tenant this execution belongs to. Can be `null`\nif the execution belongs to no single tenant.',
    )


class ExtendLockOnExternalTaskDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    worker_id: Optional[str] = Field(
        None,
        alias='workerId',
        description='The ID of a worker who is locking the external task.',
    )
    new_duration: Optional[int] = Field(
        None,
        alias='newDuration',
        description='An amount of time (in milliseconds). This is the new lock duration starting from the current moment.',
    )


class ExternalTaskDto(BaseModel):
    """
    An External Task object with the following properties
    """

    class Config:
        allow_population_by_field_name = True

    activity_id: Optional[str] = Field(
        None,
        alias='activityId',
        description='The id of the activity that this external task belongs to.',
    )
    activity_instance_id: Optional[str] = Field(
        None,
        alias='activityInstanceId',
        description='The id of the activity instance that the external task belongs to.',
    )
    error_message: Optional[str] = Field(
        None,
        alias='errorMessage',
        description='The full error message submitted with the latest reported failure executing this task; `null` if no\nfailure was reported previously or if no error message was submitted',
    )
    execution_id: Optional[str] = Field(
        None,
        alias='executionId',
        description='The id of the execution that the external task belongs to.',
    )
    id: Optional[str] = Field(None, description='The id of the external task.')
    lock_expiration_time: Optional[datetime] = Field(
        None,
        alias='lockExpirationTime',
        description="The date that the task's most recent lock expires or has expired.",
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='The id of the process definition the external task is defined in.',
    )
    process_definition_key: Optional[str] = Field(
        None,
        alias='processDefinitionKey',
        description='The key of the process definition the external task is defined in.',
    )
    process_definition_version_tag: Optional[str] = Field(
        None,
        alias='processDefinitionVersionTag',
        description='The version tag of the process definition the external task is defined in.',
    )
    process_instance_id: Optional[str] = Field(
        None,
        alias='processInstanceId',
        description='The id of the process instance the external task belongs to.',
    )
    tenant_id: Optional[str] = Field(
        None,
        alias='tenantId',
        description='The id of the tenant the external task belongs to.',
    )
    retries: Optional[int] = Field(
        None, description='The number of retries the task currently has left.'
    )
    suspended: Optional[bool] = Field(
        None,
        description='A flag indicating whether the external task is suspended or not.',
    )
    worker_id: Optional[str] = Field(
        None,
        alias='workerId',
        description='The id of the worker that posesses or posessed the most recent lock.',
    )
    topic_name: Optional[str] = Field(
        None, alias='topicName', description='The topic name of the external task.'
    )
    priority: Optional[int] = Field(
        None, description='The priority of the external task.'
    )
    business_key: Optional[str] = Field(
        None,
        alias='businessKey',
        description='The business key of the process instance the external task belongs to.',
    )


class ExternalTaskFailureDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    worker_id: Optional[str] = Field(
        None,
        alias='workerId',
        description='The id of the worker that reports the failure. Must match the id of the worker who has most recently\nlocked the task.',
    )
    error_message: Optional[str] = Field(
        None,
        alias='errorMessage',
        description='An message indicating the reason of the failure.',
    )
    error_details: Optional[str] = Field(
        None, alias='errorDetails', description='A detailed error description.'
    )
    retries: Optional[int] = Field(
        None,
        description="A number of how often the task should be retried. Must be >= 0. If this is 0, an incident is created and\nthe task cannot be fetched anymore unless the retries are increased again. The incident's message is set\nto the `errorMessage` parameter.",
    )
    retry_timeout: Optional[int] = Field(
        None,
        alias='retryTimeout',
        description='A timeout in milliseconds before the external task becomes available again for fetching. Must be >= 0.',
    )


class SortBy1(Enum):
    """
        Sort the results lexicographically by a given criterion.
    Must be used in conjunction with the sortOrder parameter.
    """

    id = 'id'
    lock_expiration_time = 'lockExpirationTime'
    process_instance_id = 'processInstanceId'
    process_definition_id = 'processDefinitionId'
    process_definition_key = 'processDefinitionKey'
    task_priority = 'taskPriority'
    tenant_id = 'tenantId'


class SortingItem1(BaseModel):
    class Config:
        allow_population_by_field_name = True

    sort_by: Optional[SortBy1] = Field(
        None,
        alias='sortBy',
        description='Sort the results lexicographically by a given criterion.\nMust be used in conjunction with the sortOrder parameter.',
    )
    sort_order: Optional[SortOrder] = Field(
        None,
        alias='sortOrder',
        description='Sort the results in a given order. Values may be `asc` for ascending order or `desc` for\ndescending order. Must be used in conjunction with the sortBy parameter.',
    )


class ExternalTaskQueryDto(BaseModel):
    """
    A JSON object with the following properties:
    """

    class Config:
        allow_population_by_field_name = True

    external_task_id: Optional[str] = Field(
        None, alias='externalTaskId', description="Filter by an external task's id."
    )
    external_task_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='externalTaskIdIn',
        description='Filter by the comma-separated list of external task ids.',
    )
    topic_name: Optional[str] = Field(
        None, alias='topicName', description='Filter by an external task topic.'
    )
    worker_id: Optional[str] = Field(
        None,
        alias='workerId',
        description='Filter by the id of the worker that the task was most recently locked by.',
    )
    locked: Optional[bool] = Field(
        None,
        description='Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired).\nValue may only be `true`, as `false` matches any external task.',
    )
    not_locked: Optional[bool] = Field(
        None,
        alias='notLocked',
        description='Only include external tasks that are currently not locked (i.e., they have no lock or it has expired).\nValue may only be `true`, as `false` matches any external task.',
    )
    with_retries_left: Optional[bool] = Field(
        None,
        alias='withRetriesLeft',
        description='Only include external tasks that have a positive (&gt; 0) number of retries (or `null`). Value may only be\n`true`, as `false` matches any external task.',
    )
    no_retries_left: Optional[bool] = Field(
        None,
        alias='noRetriesLeft',
        description='Only include external tasks that have 0 retries. Value may only be `true`, as `false` matches any\nexternal task.',
    )
    lock_expiration_after: Optional[datetime] = Field(
        None,
        alias='lockExpirationAfter',
        description="Restrict to external tasks that have a lock that expires after a given date. By\n[default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    lock_expiration_before: Optional[datetime] = Field(
        None,
        alias='lockExpirationBefore',
        description="Restrict to external tasks that have a lock that expires before a given date. By\n[default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.",
    )
    activity_id: Optional[str] = Field(
        None,
        alias='activityId',
        description='Filter by the id of the activity that an external task is created for.',
    )
    activity_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='activityIdIn',
        description='Filter by the comma-separated list of ids of the activities that an external task is created for.',
    )
    execution_id: Optional[str] = Field(
        None,
        alias='executionId',
        description='Filter by the id of the execution that an external task belongs to.',
    )
    process_instance_id: Optional[str] = Field(
        None,
        alias='processInstanceId',
        description='Filter by the id of the process instance that an external task belongs to.',
    )
    process_instance_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='processInstanceIdIn',
        description='Filter by a comma-separated list of process instance ids that an external task may belong to.',
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='Filter by the id of the process definition that an external task belongs to.',
    )
    tenant_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='tenantIdIn',
        description='Filter by a comma-separated list of tenant ids.\nAn external task must have one of the given tenant ids.',
    )
    active: Optional[bool] = Field(
        None,
        description='Only include active tasks. Value may only be `true`, as `false` matches any external task.',
    )
    suspended: Optional[bool] = Field(
        None,
        description='Only include suspended tasks. Value may only be `true`, as `false` matches any external task.',
    )
    priority_higher_than_or_equals: Optional[int] = Field(
        None,
        alias='priorityHigherThanOrEquals',
        description='Only include jobs with a priority higher than or equal to the given value.\nValue must be a valid `long` value.',
    )
    priority_lower_than_or_equals: Optional[int] = Field(
        None,
        alias='priorityLowerThanOrEquals',
        description='Only include jobs with a priority lower than or equal to the given value.\nValue must be a valid `long` value.',
    )
    sorting: Optional[Sequence[SortingItem1]] = Field(
        None,
        description='A JSON array of criteria to sort the result by. Each element of the array is a JSON object that\n                    specifies one ordering. The position in the array identifies the rank of an ordering, i.e., whether\n                    it is primary, secondary, etc. The ordering objects have the following properties:\n\n                    **Note:** The `sorting` properties will not be applied to the External Task count query.',
    )


class FetchExternalTaskTopicDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    topic_name: str = Field(
        ..., alias='topicName', description="**Mandatory.** The topic's name."
    )
    lock_duration: int = Field(
        ...,
        alias='lockDuration',
        description='**Mandatory.** The duration to lock the external tasks for in milliseconds.',
    )
    variables: Optional[Sequence[str]] = Field(
        None,
        description="A JSON array of `String` values that represent variable names. For each result task belonging to this\ntopic, the given variables are returned as well if they are accessible from the external task's\nexecution. If not provided - all variables will be fetched.",
    )
    local_variables: Optional[bool] = Field(
        False,
        alias='localVariables',
        description='If `true` only local variables will be fetched.',
    )
    business_key: Optional[str] = Field(
        None,
        alias='businessKey',
        description='A `String` value which enables the filtering of tasks based on process instance business key.',
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='Filter tasks based on process definition id.',
    )
    process_definition_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='processDefinitionIdIn',
        description='Filter tasks based on process definition ids.',
    )
    process_definition_key: Optional[str] = Field(
        None,
        alias='processDefinitionKey',
        description='Filter tasks based on process definition key.',
    )
    process_definition_key_in: Optional[Sequence[str]] = Field(
        None,
        alias='processDefinitionKeyIn',
        description='Filter tasks based on process definition keys.',
    )
    process_definition_version_tag: Optional[str] = Field(
        None,
        alias='processDefinitionVersionTag',
        description='Filter tasks based on process definition version tag.',
    )
    without_tenant_id: Optional[bool] = Field(
        False, alias='withoutTenantId', description='Filter tasks without tenant id.'
    )
    tenant_id_in: Optional[Sequence[str]] = Field(
        None, alias='tenantIdIn', description='Filter tasks based on tenant ids.'
    )
    process_variables: Optional[Mapping[str, Any]] = Field(
        None,
        alias='processVariables',
        description='A `JSON` object used for filtering tasks based on process instance variable values. A property name of\nthe object represents a process variable name, while the property value represents the process variable\nvalue to filter tasks by.',
    )
    deserialize_values: Optional[bool] = Field(
        False,
        alias='deserializeValues',
        description="Determines whether serializable variable values (typically variables that store custom Java objects)\nshould be deserialized on server side (default `false`).\n\nIf set to `true`, a serializable variable will be deserialized on server side and transformed to JSON\nusing [Jackson's](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note\nthat this requires the Java classes of the variable value to be on the REST API's classpath.\n\nIf set to `false`, a serializable variable will be returned in its serialized format. For example, a\nvariable that is serialized as XML will be returned as a JSON string containing XML.",
    )


class FetchExternalTasksDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    worker_id: str = Field(
        ...,
        alias='workerId',
        description='**Mandatory.** The id of the worker on which behalf tasks are fetched. The returned tasks are locked for\nthat worker and can only be completed when providing the same worker id.',
    )
    max_tasks: int = Field(
        ...,
        alias='maxTasks',
        description='**Mandatory.** The maximum number of tasks to return.',
    )
    use_priority: Optional[bool] = Field(
        None,
        alias='usePriority',
        description='A `boolean` value, which indicates whether the task should be fetched based on its priority\nor arbitrarily.',
    )
    async_response_timeout: Optional[int] = Field(
        None,
        alias='asyncResponseTimeout',
        description='The [Long Polling](https://docs.camunda.org/manual/7.13/user-guide/process-engine/external-tasks/#long-polling-to-fetch-and-lock-external-tasks)\ntimeout in milliseconds.\n\n**Note:** The value cannot be set larger than 1.800.000 milliseconds (corresponds to 30 minutes).',
    )
    topics: Optional[Sequence[FetchExternalTaskTopicDto]] = Field(
        None,
        description='A JSON array of topic objects for which external tasks should be fetched. The returned tasks may be\narbitrarily distributed among these topics. Each topic object has the following properties:',
    )


class FormDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    key: Optional[str] = Field(None, description='The form key.')
    context_path: Optional[str] = Field(
        None,
        alias='contextPath',
        description='The context path of the process application. If the task (or the process definition) does not\nbelong to a process application deployment or a process definition at all, this\nproperty is not set.',
    )


class IncidentStatus(Enum):
    """
        Only include process instances which have an incident in status either open or resolved.
    To get all process instances, use the query parameter withIncidents.
    """

    open = 'open'
    resolved = 'resolved'


class SortBy2(Enum):
    """
        Sort the results lexicographically by a given criterion.
    Must be used in conjunction with the sortOrder parameter.
    """

    instance_id = 'instanceId'
    definition_id = 'definitionId'
    definition_key = 'definitionKey'
    definition_name = 'definitionName'
    definition_version = 'definitionVersion'
    business_key = 'businessKey'
    start_time = 'startTime'
    end_time = 'endTime'
    duration = 'duration'
    tenant_id = 'tenantId'


class SortingItem2(BaseModel):
    class Config:
        allow_population_by_field_name = True

    sort_by: Optional[SortBy2] = Field(
        None,
        alias='sortBy',
        description='Sort the results lexicographically by a given criterion.\nMust be used in conjunction with the sortOrder parameter.',
    )
    sort_order: Optional[SortOrder] = Field(
        None,
        alias='sortOrder',
        description='Sort the results in a given order. Values may be `asc` for ascending order or `desc` for\ndescending order. Must be used in conjunction with the sortBy parameter.',
    )


class HistoryTimeToLiveDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    history_time_to_live: Optional[conint(ge=0)] = Field(
        None,
        alias='historyTimeToLive',
        description='New value for historyTimeToLive field of the definition.\nCan be `null`. Can not be negative.',
    )


class IdentityLinkDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    user_id: Optional[str] = Field(
        None,
        alias='userId',
        description='The id of the user participating in this link. Either `userId` or `groupId` is set.',
    )
    group_id: Optional[str] = Field(
        None,
        alias='groupId',
        description='The id of the group participating in this link. Either `groupId` or `userId` is set.',
    )
    type: str = Field(
        ...,
        description='The type of the identity link. The value of the this property can be user-defined. The Process Engine\nprovides three pre-defined Identity Link `type`s:\n\n* `candidate`\n* `assignee` - reserved for the task assignee\n* `owner` - reserved for the task owner\n\n**Note**: When adding or removing an Identity Link, the `type` property must be defined.',
    )


class IncidentStatisticsResultDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    incident_type: Optional[str] = Field(
        None,
        alias='incidentType',
        description='The type of the incident the number of incidents is aggregated for. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.',
    )
    incident_count: Optional[int] = Field(
        None,
        alias='incidentCount',
        description='The total number of incidents for the corresponding incident type.',
    )


class LinkableDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    links: Optional[Sequence[AtomLink]] = Field(
        None,
        description='The links associated to this resource, with `method`, `href` and `rel`.',
    )


class ResultType(Enum):
    """
        Indicates if the message was correlated to a message start event or an
    intermediate message catching event. In the first case, the resultType is
    `ProcessDefinition` and otherwise `Execution`.
    """

    execution = 'Execution'
    process_definition = 'ProcessDefinition'


class MetricsIntervalResultDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    timestamp: Optional[datetime] = Field(None, description='The interval timestamp.')
    name: Optional[str] = Field(None, description='The name of the metric.')
    reporter: Optional[str] = Field(
        None,
        description='The reporter of the metric. `null` if the metrics are aggregated by reporter.',
    )
    value: Optional[int] = Field(
        None, description='The value of the metric aggregated by the interval.'
    )


class MetricsResultDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    result: Optional[int] = Field(
        None, description='The current sum (count) for the selected metric.'
    )


class MissingAuthorizationDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    permission_name: Optional[str] = Field(
        None,
        alias='permissionName',
        description='The permission name that the user is missing.',
    )
    resource_name: Optional[str] = Field(
        None,
        alias='resourceName',
        description='The name of the resource that the user is missing permission for.',
    )
    resource_id: Optional[str] = Field(
        None,
        alias='resourceId',
        description='The id of the resource that the user is missing permission for.',
    )


class MultiFormAttachmentDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    attachment_name: Optional[str] = Field(
        None, alias='attachment-name', description='The name of the attachment.'
    )
    attachment_description: Optional[str] = Field(
        None,
        alias='attachment-description',
        description='The description of the attachment.',
    )
    attachment_type: Optional[str] = Field(
        None, alias='attachment-type', description='The type of the attachment.'
    )
    url: Optional[str] = Field(
        None, description='The url to the remote content of the attachment.'
    )
    content: Optional[bytes] = Field(None, description='The content of the attachment.')


class MultiFormDeploymentDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    tenant_id: Optional[str] = Field(
        None,
        alias='tenant-id',
        description='The tenant id for the deployment to be created.',
    )
    deployment_source: Optional[str] = Field(
        None,
        alias='deployment-source',
        description='The source for the deployment to be created.',
    )
    deploy_changed_only: Optional[bool] = Field(
        False,
        alias='deploy-changed-only',
        description='A flag indicating whether the process engine should perform duplicate checking on a per-resource basis.\nIf set to true, only those resources that have actually changed are deployed.\nChecks are made against resources included previous deployments of the same name and only against the latest versions of those resources.\nIf set to true, the option enable-duplicate-filtering is overridden and set to true.',
    )
    enable_duplicate_filtering: Optional[bool] = Field(
        False,
        alias='enable-duplicate-filtering',
        description='A flag indicating whether the process engine should perform duplicate checking for the deployment or not.\nThis allows you to check if a deployment with the same name and the same resouces already exists and\nif true, not create a new deployment but instead return the existing deployment. The default value is false.',
    )
    deployment_name: Optional[str] = Field(
        None,
        alias='deployment-name',
        description='The name for the deployment to be created.',
    )
    data: Optional[bytes] = Field(
        None,
        description='The binary data to create the deployment resource.\nIt is possible to have more than one form part with different form part names for the binary data to create a deployment.',
    )


class ValueType(Enum):
    """
    The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
    """

    bytes = 'Bytes'
    file = 'File'


class MultiFormVariableBinaryDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    data: Optional[bytes] = Field(
        None,
        description='The binary data to be set.\nFor File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set\nOnly the filename is mandatory.',
    )
    value_type: Optional[ValueType] = Field(
        None,
        alias='valueType',
        description='The name of the variable type. Either Bytes for a byte array variable or File for a file variable.',
    )


class PriorityDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    priority: Optional[int] = Field(None, description='The priority of the resource.')


class ProblemDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    message: Optional[str] = Field(None, description='The message of the problem.')
    line: Optional[int] = Field(
        None, description='The line where the problem occurred.'
    )
    column: Optional[int] = Field(
        None, description='The column where the problem occurred.'
    )
    main_element_id: Optional[str] = Field(
        None,
        alias='mainElementId',
        description='The main element id where the problem occurred.',
    )
    element_ids: Optional[Sequence[str]] = Field(
        None,
        alias='elementIds',
        description='A list of element id affected by the problem.',
    )


class ProcessDefinitionDiagramDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the process definition.')
    bpmn20_xml: Optional[str] = Field(
        None,
        alias='bpmn20Xml',
        description='An escaped XML string containing the XML that this definition was deployed with.\nCarriage returns, line feeds and quotation marks are escaped.',
    )


class ProcessDefinitionDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the process definition')
    key: Optional[str] = Field(
        None,
        description='The key of the process definition, i.e., the id of the BPMN 2.0 XML process definition.',
    )
    category: Optional[str] = Field(
        None, description='The category of the process definition.'
    )
    description: Optional[str] = Field(
        None, description='The description of the process definition.'
    )
    name: Optional[str] = Field(None, description='The name of the process definition.')
    version: Optional[int] = Field(
        None,
        description='The version of the process definition that the engine assigned to it.',
    )
    resource: Optional[str] = Field(
        None, description='The file name of the process definition.'
    )
    deployment_id: Optional[str] = Field(
        None,
        alias='deploymentId',
        description='The deployment id of the process definition.',
    )
    diagram: Optional[str] = Field(
        None,
        description='The file name of the process definition diagram, if it exists.',
    )
    suspended: Optional[bool] = Field(
        None,
        description='A flag indicating whether the definition is suspended or not.',
    )
    tenant_id: Optional[str] = Field(
        None, alias='tenantId', description='The tenant id of the process definition.'
    )
    version_tag: Optional[str] = Field(
        None,
        alias='versionTag',
        description='The version tag of the process definition.',
    )
    history_time_to_live: Optional[conint(ge=0)] = Field(
        None,
        alias='historyTimeToLive',
        description='History time to live value of the process definition.\nIs used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).',
    )
    startable_in_tasklist: Optional[bool] = Field(
        None,
        alias='startableInTasklist',
        description='A flag indicating whether the process definition is startable in Tasklist or not.',
    )


class ProcessDefinitionStatisticsResultDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(
        None,
        description='The id of the process definition the results are aggregated for.',
    )
    instances: Optional[int] = Field(
        None,
        description='The total number of running process instances of this process definition.',
    )
    failed_jobs: Optional[int] = Field(
        None,
        alias='failedJobs',
        description='The total number of failed jobs for the running instances.\n**Note**: Will be `0` (not `null`), if failed jobs were excluded.',
    )
    incidents: Optional[Sequence[IncidentStatisticsResultDto]] = Field(
        None,
        description='Each item in the resulting array is an object which contains `incidentType` and `incidentCount`.\n**Note**: Will be an empty array, if `incidents` or `incidentsForType` were excluded.\nFurthermore, the array will be also empty if no incidents were found.',
    )
    definition: Optional[ProcessDefinitionDto] = None


class ProcessDefinitionSuspensionStateDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    suspended: Optional[bool] = Field(
        None,
        description='A `Boolean` value which indicates whether to activate or suspend all process definitions with the given key.\nWhen the value is set to `true`, all process definitions with the given key will be suspended and\nwhen the value is set to `false`, all process definitions with the given key will be activated.',
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='The id of the process definitions to activate or suspend.',
    )
    process_definition_key: Optional[str] = Field(
        None,
        alias='processDefinitionKey',
        description='\tThe key of the process definitions to activate or suspend.',
    )
    include_process_instances: Optional[bool] = Field(
        None,
        alias='includeProcessInstances',
        description='A `Boolean` value which indicates whether to activate or suspend also all process instances of \nthe process definitions with the given key.\nWhen the value is set to `true`, all process instances of the process definitions with the given key\nwill be activated or suspended and when the value is set to `false`, the suspension state of \nall process instances of the process definitions with the given key will not be updated.',
    )
    execution_date: Optional[datetime] = Field(
        None,
        alias='executionDate',
        description="The date on which all process definitions with the given key will be activated or suspended.\nIf `null`, the suspension state of all process definitions with the given key is updated immediately.\nBy [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/),\nthe date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.",
    )


class ProcessEngineDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[str] = Field(None, description='The name of the process engine.')


class ProcessInstanceDto(LinkableDto):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the process instance.')
    definition_id: Optional[str] = Field(
        None,
        alias='definitionId',
        description='The id of the process definition that this process instance belongs to.',
    )
    business_key: Optional[str] = Field(
        None,
        alias='businessKey',
        description='The business key of the process instance.',
    )
    case_instance_id: Optional[str] = Field(
        None,
        alias='caseInstanceId',
        description='The id of the case instance associated with the process instance.',
    )
    ended: Optional[bool] = Field(
        None,
        description='A flag indicating whether the process instance has ended or not. Deprecated: will always be false!',
    )
    suspended: Optional[bool] = Field(
        None,
        description='A flag indicating whether the process instance is suspended or not.',
    )
    tenant_id: Optional[str] = Field(
        None, alias='tenantId', description='The tenant id of the process instance.'
    )


class Type(Enum):
    """
        **Mandatory**. One of the following values: `cancel`, `startBeforeActivity`, `startAfterActivity`, `startTransition`.

    * A cancel instruction requests cancellation of a single activity instance or all instances of one activity.
    * A startBeforeActivity instruction requests to enter a given activity.
    * A startAfterActivity instruction requests to execute the single outgoing sequence flow of a given activity.
    * A startTransition instruction requests to execute a specific sequence flow.
    """

    cancel = 'cancel'
    start_before_activity = 'startBeforeActivity'
    start_after_activity = 'startAfterActivity'
    start_transition = 'startTransition'


class SortBy3(Enum):
    """
        Sort the results lexicographically by a given criterion.
    Must be used in conjunction with the sortOrder parameter.
    """

    instance_id = 'instanceId'
    definition_id = 'definitionId'
    definition_key = 'definitionKey'
    business_key = 'businessKey'
    tenant_id = 'tenantId'


class SortingItem3(BaseModel):
    class Config:
        allow_population_by_field_name = True

    sort_by: Optional[SortBy3] = Field(
        None,
        alias='sortBy',
        description='Sort the results lexicographically by a given criterion.\nMust be used in conjunction with the sortOrder parameter.',
    )
    sort_order: Optional[SortOrder] = Field(
        None,
        alias='sortOrder',
        description='Sort the results in a given order. Values may be `asc` for ascending order or `desc` for\ndescending order. Must be used in conjunction with the sortBy parameter.',
    )


class RedeploymentDto(BaseModel):
    """
    A JSON object with the following properties:
    """

    class Config:
        allow_population_by_field_name = True

    resource_ids: Optional[Sequence[str]] = Field(
        None,
        alias='resourceIds',
        description='A list of deployment resource ids to re-deploy.',
    )
    resource_names: Optional[Sequence[str]] = Field(
        None,
        alias='resourceNames',
        description='A list of deployment resource names to re-deploy.',
    )
    source: Optional[str] = Field(
        None, description='Sets the source of the deployment.'
    )


class ResourceReportDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    errors: Optional[Sequence[ProblemDto]] = Field(
        None, description='A list of errors occurred during parsing.'
    )
    warnings: Optional[Sequence[ProblemDto]] = Field(
        None, description='A list of warnings occurred during parsing.'
    )


class Type1(Enum):
    """
        **Mandatory**. One of the following values: `startBeforeActivity`, `startAfterActivity`, `startTransition`.

    * A `startBeforeActivity` instruction requests to enter a given activity.
    * A `startAfterActivity` instruction requests to execute the single outgoing sequence flow of a given activity.
    * A `startTransition` instruction requests to execute a specific sequence flow.
    """

    start_before_activity = 'startBeforeActivity'
    start_after_activity = 'startAfterActivity'
    start_transition = 'startTransition'


class RestartProcessInstanceModificationInstructionDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    type: Type1 = Field(
        ...,
        description='**Mandatory**. One of the following values: `startBeforeActivity`, `startAfterActivity`, `startTransition`.\n\n* A `startBeforeActivity` instruction requests to enter a given activity.\n* A `startAfterActivity` instruction requests to execute the single outgoing sequence flow of a given activity.\n* A `startTransition` instruction requests to execute a specific sequence flow.',
    )
    activity_id: Optional[str] = Field(
        None,
        alias='activityId',
        description='**Can be used with instructions of types** `startBeforeActivity`\nand `startAfterActivity`. Specifies the sequence flow to start.',
    )
    transition_id: Optional[str] = Field(
        None,
        alias='transitionId',
        description='**Can be used with instructions of types** `startTransition`.\nSpecifies the sequence flow to start.',
    )


class RetriesDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    retries: Optional[int] = Field(
        None,
        description='The number of retries to set for the resource.  Must be >= 0. If this is 0, an incident is created\nand the task, or job, cannot be fetched, or acquired anymore unless the retries are increased again.\nCan not be null.',
    )


class SchemaLogEntryDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the schema log entry.')
    timestamp: Optional[datetime] = Field(
        None, description='The date and time of the schema update.'
    )
    version: Optional[str] = Field(None, description='The version of the schema.')


class SortBy4(Enum):
    """
        Sort the results lexicographically by a given criterion.
    Must be used in conjunction with the sortOrder parameter.
    """

    timestamp = 'timestamp'


class SortingItem4(BaseModel):
    class Config:
        allow_population_by_field_name = True

    sort_by: Optional[SortBy4] = Field(
        None,
        alias='sortBy',
        description='Sort the results lexicographically by a given criterion.\nMust be used in conjunction with the sortOrder parameter.',
    )
    sort_order: Optional[SortOrder] = Field(
        None,
        alias='sortOrder',
        description='Sort the results in a given order. Values may be `asc` for ascending order or `desc` for\ndescending order. Must be used in conjunction with the sortBy parameter.',
    )


class SchemaLogQueryDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    version: Optional[str] = Field(None, description='The version of the schema.')
    sorting: Optional[Sequence[SortingItem4]] = Field(
        None,
        description='A JSON array of criteria to sort the result by. Each element of the array is\n                      a JSON object that specifies one ordering. The position in the array\n                      identifies the rank of an ordering, i.e., whether it is primary, secondary,\n                      etc. ',
    )


class SortTaskQueryParametersDto(BaseModel):
    """
        Mandatory when `sortBy` is one of the following values: `processVariable`, `executionVariable`,
    `taskVariable`, `caseExecutionVariable` or `caseInstanceVariable`. Must be a JSON object with the properties
    `variable` and `type` where `variable` is a variable name and `type` is the name of a variable value type.
    """

    class Config:
        allow_population_by_field_name = True

    variable: Optional[str] = Field(
        None, description='The name of the variable to sort by.'
    )
    type: Optional[str] = Field(
        None, description='The name of the type of the variable value.'
    )


class SuspensionStateDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    suspended: Optional[bool] = Field(
        None,
        description='A Boolean value which indicates whether to activate or suspend a given process instance.\nWhen the value is set to true, the given process instance will be suspended and when the value is set to false,\nthe given process instance will be activated.',
    )


class DelegationState(Enum):
    """
    The task's delegation state. Possible values are `PENDING` and `RESOLVED`.
    """

    pending = 'PENDING'
    resolved = 'RESOLVED'


class TaskDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The task id.')
    name: Optional[str] = Field(None, description='The task name.')
    assignee: Optional[str] = Field(None, description="The assignee's id.")
    owner: Optional[str] = Field(None, description="The owner's id.")
    created: Optional[datetime] = Field(
        None,
        description="The date the task was created on.\n[Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    due: Optional[datetime] = Field(
        None,
        description="The task's due date.\n[Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    follow_up: Optional[datetime] = Field(
        None,
        alias='followUp',
        description="The follow-up date for the task.\n[Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    delegation_state: Optional[DelegationState] = Field(
        None,
        alias='delegationState',
        description="The task's delegation state. Possible values are `PENDING` and `RESOLVED`.",
    )
    description: Optional[str] = Field(None, description="The task's description.")
    execution_id: Optional[str] = Field(
        None,
        alias='executionId',
        description='The id of the execution the task belongs to.',
    )
    parent_task_id: Optional[str] = Field(
        None,
        alias='parentTaskId',
        description='The id the parent task, if this task is a subtask.',
    )
    priority: Optional[int] = Field(None, description="The task's priority.")
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='The id of the process definition the task belongs to.',
    )
    process_instance_id: Optional[str] = Field(
        None,
        alias='processInstanceId',
        description='The id of the process instance the task belongs to.',
    )
    case_execution_id: Optional[str] = Field(
        None,
        alias='caseExecutionId',
        description='The id of the case execution the task belongs to.',
    )
    case_definition_id: Optional[str] = Field(
        None,
        alias='caseDefinitionId',
        description='The id of the case definition the task belongs to.',
    )
    case_instance_id: Optional[str] = Field(
        None,
        alias='caseInstanceId',
        description='The id of the case instance the task belongs to.',
    )
    task_definition_key: Optional[str] = Field(
        None, alias='taskDefinitionKey', description="The task's key."
    )
    suspended: Optional[bool] = Field(
        None,
        description='Whether the task belongs to a process instance that is suspended.',
    )
    form_key: Optional[str] = Field(
        None, alias='formKey', description='If not `null`, the form key for the task.'
    )
    tenant_id: Optional[str] = Field(
        None, alias='tenantId', description='If not `null`, the tenant id of the task.'
    )


class SortBy5(Enum):
    """
        Sort the results lexicographically by a given criterion.
    Must be used in conjunction with the sortOrder parameter.
    """

    instance_id = 'instanceId'
    case_instance_id = 'caseInstanceId'
    due_date = 'dueDate'
    execution_id = 'executionId'
    case_execution_id = 'caseExecutionId'
    assignee = 'assignee'
    created = 'created'
    description = 'description'
    id = 'id'
    name = 'name'
    name_case_insensitive = 'nameCaseInsensitive'
    priority = 'priority'
    process_variable = 'processVariable'
    execution_variable = 'executionVariable'
    task_variable = 'taskVariable'
    case_execution_variable = 'caseExecutionVariable'
    case_instance_variable = 'caseInstanceVariable'


class SortingItem5(BaseModel):
    class Config:
        allow_population_by_field_name = True

    sort_by: Optional[SortBy5] = Field(
        None,
        alias='sortBy',
        description='Sort the results lexicographically by a given criterion.\nMust be used in conjunction with the sortOrder parameter.',
    )
    sort_order: Optional[SortOrder] = Field(
        None,
        alias='sortOrder',
        description='Sort the results in a given order. Values may be `asc` for ascending order or `desc` for\ndescending order. Must be used in conjunction with the sortBy parameter.',
    )
    parameters: Optional[SortTaskQueryParametersDto] = None


class TransitionInstanceDto(BaseModel):
    """
    A JSON object corresponding to the Activity Instance tree of the given process instance.
    """

    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the transition instance.')
    parent_activity_instance_id: Optional[str] = Field(
        None,
        alias='parentActivityInstanceId',
        description='The id of the parent activity instance, for example a sub process instance.',
    )
    activity_id: Optional[str] = Field(
        None,
        alias='activityId',
        description='The id of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)',
    )
    activity_name: Optional[str] = Field(
        None,
        alias='activityName',
        description='The name of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)',
    )
    activity_type: Optional[str] = Field(
        None,
        alias='activityType',
        description='The type of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)',
    )
    process_instance_id: Optional[str] = Field(
        None,
        alias='processInstanceId',
        description='The id of the process instance this instance is part of.',
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='The id of the process definition.',
    )
    execution_id: Optional[str] = Field(
        None, alias='executionId', description='The execution id.'
    )
    incident_ids: Optional[Sequence[str]] = Field(
        None, alias='incidentIds', description='A list of incident ids.'
    )
    incidents: Optional[Sequence[ActivityInstanceIncidentDto]] = Field(
        None,
        description='A list of JSON objects containing incident specific properties:\n* `id`: the id of the incident\n* `activityId`: the activity id in which the incident occurred',
    )


class UserIdDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    user_id: Optional[str] = Field(
        None,
        alias='userId',
        description='The id of the user that the current action refers to.',
    )


class Operator(Enum):
    """
    Comparison operator to be used
    """

    eq = 'eq'
    neq = 'neq'
    gt = 'gt'
    gteq = 'gteq'
    lt = 'lt'
    lteq = 'lteq'
    like = 'like'


class VariableQueryParameterDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    value: Optional[Mapping[str, Any]] = Field(
        None,
        description='The variable value, could be of type boolean, string or number',
    )
    operator: Optional[Operator] = Field(
        None, description='Comparison operator to be used'
    )


class VariableValueDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    value: Optional[Mapping[str, Any]] = Field(
        None,
        description="The variable's value. Value differs depending on the variable's type and on the deserializeValues parameter.",
    )
    type: Optional[str] = Field(None, description='The value type of the variable.')
    value_info: Optional[Mapping[str, Any]] = Field(
        None,
        alias='valueInfo',
        description="A JSON object containing additional, value-type-dependent properties.\nFor serialized variables of type Object, the following properties can be provided:\n\n* `objectTypeName`: A string representation of the object's type name.\n* `serializationDataFormat`: The serialization format used to store the variable.\n\nFor serialized variables of type File, the following properties can be provided:\n\n* `filename`: The name of the file. This is not the variable name but the name that will be used when downloading the file again.\n* `mimetype`: The MIME type of the file that is being uploaded.\n* `encoding`: The encoding of the file that is being uploaded.",
    )


class VersionDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    version: Optional[str] = Field(None, description='The version of the Rest API.')


class ActivityInstanceDto(BaseModel):
    """
    A JSON object corresponding to the Activity Instance tree of the given process instance.
    """

    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the activity instance.')
    parent_activity_instance_id: Optional[str] = Field(
        None,
        alias='parentActivityInstanceId',
        description='The id of the parent activity instance, for example a sub process instance.',
    )
    activity_id: Optional[str] = Field(
        None, alias='activityId', description='The id of the activity.'
    )
    activity_name: Optional[str] = Field(
        None, alias='activityName', description='The name of the activity'
    )
    activity_type: Optional[str] = Field(
        None,
        alias='activityType',
        description="The type of activity (corresponds to the XML element name in the BPMN 2.0, e.g., 'userTask')",
    )
    process_instance_id: Optional[str] = Field(
        None,
        alias='processInstanceId',
        description='The id of the process instance this activity instance is part of.',
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='The id of the process definition.',
    )
    child_activity_instances: Optional[Sequence[ActivityInstanceDto]] = Field(
        None,
        alias='childActivityInstances',
        description='A list of child activity instances.',
    )
    child_transition_instances: Optional[Sequence[TransitionInstanceDto]] = Field(
        None,
        alias='childTransitionInstances',
        description='A list of child transition instances.\nA transition instance represents an execution waiting in an asynchronous continuation.',
    )
    execution_ids: Optional[Sequence[str]] = Field(
        None, alias='executionIds', description='A list of execution ids.'
    )
    incident_ids: Optional[Sequence[str]] = Field(
        None, alias='incidentIds', description='A list of incident ids.'
    )
    incidents: Optional[Sequence[ActivityInstanceIncidentDto]] = Field(
        None,
        description='A list of JSON objects containing incident specific properties:\n* `id`: the id of the incident\n* `activityId`: the activity id in which the incident occurred',
    )


class ActivityStatisticsResultDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(
        None, description='The id of the activity the results are aggregated for.'
    )
    instances: Optional[int] = Field(
        None,
        description='The total number of running process instances of this activity.',
    )
    failed_jobs: Optional[int] = Field(
        None,
        alias='failedJobs',
        description='The total number of failed jobs for the running instances.\n**Note**: Will be `0` (not `null`), if failed jobs were excluded.',
    )
    incidents: Optional[Sequence[IncidentStatisticsResultDto]] = Field(
        None,
        description='Each item in the resulting array is an object which contains `incidentType` and `incidentCount`.\n**Note**: Will be an empty array, if `incidents` or `incidentsForType` were excluded.\nFurthermore, the array will be also empty if no incidents were found.',
    )


class AttachmentDto(LinkableDto):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the task attachment.')
    name: Optional[str] = Field(None, description='The name of the task attachment.')
    description: Optional[str] = Field(
        None, description='The description of the task attachment.'
    )
    task_id: Optional[str] = Field(
        None,
        alias='taskId',
        description='The id of the task to which the attachment belongs.',
    )
    type: Optional[str] = Field(
        None,
        description='Indication of the type of content that this attachment refers to.\nCan be MIME type or any other indication.',
    )
    url: Optional[str] = Field(
        None, description='The url to the remote content of the task attachment.'
    )
    create_time: Optional[datetime] = Field(
        None,
        alias='createTime',
        description="The time the variable was inserted.\n[Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    removal_time: Optional[datetime] = Field(
        None,
        alias='removalTime',
        description="The time after which the attachment should be removed by the History Cleanup job.\n[Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    root_process_instance_id: Optional[str] = Field(
        None,
        alias='rootProcessInstanceId',
        description='The process instance id of the root process instance that initiated the process containing the task.',
    )


class AuthorizationExceptionDto(ExceptionDto):
    class Config:
        allow_population_by_field_name = True

    user_id: Optional[str] = Field(
        None,
        alias='userId',
        description='The id of the user that does not have expected permissions',
    )
    missing_authorizations: Optional[Sequence[MissingAuthorizationDto]] = Field(
        None, alias='missingAuthorizations', description=''
    )


class CommentDto(LinkableDto):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the task comment.')
    user_id: Optional[str] = Field(
        None, alias='userId', description='The id of the user who created the comment.'
    )
    task_id: Optional[str] = Field(
        None,
        alias='taskId',
        description='The id of the task to which the comment belongs.',
    )
    time: Optional[datetime] = Field(
        None,
        description="The time when the comment was created.\n[Default format]($(docsUrl)/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    message: Optional[str] = Field(None, description='The content of the comment.')
    removal_time: Optional[datetime] = Field(
        None,
        alias='removalTime',
        description="The time after which the comment should be removed by the History Cleanup job.\n[Default format]($(docsUrl)/reference/rest/overview/date-format/)\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`.",
    )
    root_process_instance_id: Optional[str] = Field(
        None,
        alias='rootProcessInstanceId',
        description='The process instance id of the root process instance that initiated the process\ncontaining the task.',
    )


class CompleteExternalTaskDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    worker_id: Optional[str] = Field(
        None,
        alias='workerId',
        description='The id of the worker that completes the task. Must match the id of the worker who has most recently locked the task.',
    )
    variables: Optional[Mapping[str, VariableValueDto]] = Field(
        None,
        description='A JSON object containing variable key-value pairs. Each key is a variable name and each value a JSON variable value object with the following properties:',
    )
    local_variables: Optional[Mapping[str, VariableValueDto]] = Field(
        None,
        alias='localVariables',
        description='A JSON object containing local variable key-value pairs. Local variables are set only in the scope of external task. Each key is a variable name and each value a JSON variable value object with the following properties:',
    )


class CompleteTaskDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    variables: Optional[Mapping[str, VariableValueDto]] = Field(
        None, description='A JSON object containing variable key-value pairs.'
    )
    with_variables_in_return: Optional[bool] = Field(
        False,
        alias='withVariablesInReturn',
        description="Indicates whether the response should contain the process variables or not. The\ndefault is `false` with a response code of `204`. If set to `true` the response\ncontains the process variables and has a response code of `200`. If the task is not\nassociated with a process instance (e.g. if it's part of a case instance) no\nvariables will be returned.",
    )


class CorrelationMessageDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    message_name: Optional[str] = Field(
        None, alias='messageName', description='The name of the message to deliver.'
    )
    business_key: Optional[str] = Field(
        None,
        alias='businessKey',
        description='Used for correlation of process instances that wait for incoming messages.\nWill only correlate to executions that belong to a process instance with the provided business key.',
    )
    tenant_id: Optional[str] = Field(
        None,
        alias='tenantId',
        description='Used to correlate the message for a tenant with the given id.\nWill only correlate to executions and process definitions which belong to the tenant.\nMust not be supplied in conjunction with a `withoutTenantId`.',
    )
    without_tenant_id: Optional[bool] = Field(
        False,
        alias='withoutTenantId',
        description='A Boolean value that indicates whether the message should only be correlated to executions\nand process definitions which belong to no tenant or not. Value may only be `true`, as `false`\nis the default behavior.\nMust not be supplied in conjunction with a `tenantId`.',
    )
    process_instance_id: Optional[str] = Field(
        None,
        alias='processInstanceId',
        description='Used to correlate the message to the process instance with the given id.',
    )
    correlation_keys: Optional[Mapping[str, VariableValueDto]] = Field(
        None,
        alias='correlationKeys',
        description='Used for correlation of process instances that wait for incoming messages.\nHas to be a JSON object containing key-value pairs that are matched against process instance variables\nduring correlation. Each key is a variable name and each value a JSON variable value object with the\nfollowing properties.',
    )
    local_correlation_keys: Optional[Mapping[str, VariableValueDto]] = Field(
        None,
        alias='localCorrelationKeys',
        description='Local variables used for correlation of executions (process instances) that wait for incoming messages.\nHas to be a JSON object containing key-value pairs that are matched against local variables during correlation.\nEach key is a variable name and each value a JSON variable value object with the following properties.',
    )
    process_variables: Optional[Mapping[str, VariableValueDto]] = Field(
        None,
        alias='processVariables',
        description='A map of variables that is injected into the triggered execution or process instance after the message\nhas been delivered. Each key is a variable name and each value a JSON variable value object with\nthe following properties.',
    )
    process_variables_local: Optional[Mapping[str, VariableValueDto]] = Field(
        None,
        alias='processVariablesLocal',
        description='A map of local variables that is injected into the triggered execution or process instance after the\nmessage has been delivered. Each key is a variable name and each value a JSON variable value object\nwith the following properties.',
    )
    all: Optional[bool] = Field(
        False,
        description='A Boolean value that indicates whether the message should be correlated to exactly one entity or multiple entities.\nIf the value is set to `false`, the message will be correlated to exactly one entity (execution or process definition).\nIf the value is set to `true`, the message will be correlated to multiple executions and a process definition that\ncan be instantiated by this message in one go.',
    )
    result_enabled: Optional[bool] = Field(
        False,
        alias='resultEnabled',
        description='A Boolean value that indicates whether the result of the correlation should be returned or not.\nIf this property is set to `true`, there will be returned a list of message correlation result objects. Depending on the\nall property, there will be either one ore more returned results in the list.\n\nThe default value is `false`, which means no result will be returned.',
    )
    variables_in_result_enabled: Optional[bool] = Field(
        False,
        alias='variablesInResultEnabled',
        description='A Boolean value that indicates whether the result of the correlation should contain process variables or not.\nThe parameter resultEnabled should be set to `true` in order to use this it.\n\nThe default value is `false`, which means the variables will not be returned.',
    )


class DeploymentDto(LinkableDto):
    class Config:
        allow_population_by_field_name = True

    id: Optional[str] = Field(None, description='The id of the deployment.')
    tenant_id: Optional[str] = Field(
        None, alias='tenantId', description='The tenant id of the deployment.'
    )
    deployment_time: Optional[datetime] = Field(
        None,
        alias='deploymentTime',
        description='The time when the deployment was created.',
    )
    source: Optional[str] = Field(None, description='The source of the deployment.')
    name: Optional[str] = Field(None, description='The name of the deployment.')


class DeploymentWithDefinitionsDto(DeploymentDto):
    class Config:
        allow_population_by_field_name = True

    deployed_process_definitions: Optional[Mapping[str, ProcessDefinitionDto]] = Field(
        None,
        alias='deployedProcessDefinitions',
        description='A JSON Object containing a property for each of the process definitions,\nwhich are successfully deployed with that deployment.\nThe key is the process definition id, the value is a JSON Object corresponding to the process definition.',
    )
    deployed_decision_definitions: Optional[
        Mapping[str, DecisionDefinitionDto]
    ] = Field(
        None,
        alias='deployedDecisionDefinitions',
        description='A JSON Object containing a property for each of the decision definitions,\nwhich are successfully deployed with that deployment.\nThe key is the decision definition id, the value is a JSON Object corresponding to the decision definition.',
    )
    deployed_decision_requirements_definitions: Optional[
        Mapping[str, DecisionRequirementsDefinitionDto]
    ] = Field(
        None,
        alias='deployedDecisionRequirementsDefinitions',
        description='A JSON Object containing a property for each of the decision requirements definitions,\nwhich are successfully deployed with that deployment.\nThe key is the decision requirements definition id, the value is a JSON Object corresponding to the decision requirements definition.',
    )
    deployed_case_definitions: Optional[Mapping[str, CaseDefinitionDto]] = Field(
        None,
        alias='deployedCaseDefinitions',
        description='A JSON Object containing a property for each of the case definitions,\nwhich are successfully deployed with that deployment.\nThe key is the case definition id, the value is a JSON Object corresponding to the case definition.',
    )


class EvaluationConditionDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    variables: Optional[Mapping[str, VariableValueDto]] = Field(
        None,
        description='A map of variables which are used for evaluation of the conditions and are injected into the process instances which have been triggered.\nEach key is a variable name and each value a JSON variable value object with the following properties.',
    )
    business_key: Optional[str] = Field(
        None,
        alias='businessKey',
        description='Used for the process instances that have been triggered after the evaluation.',
    )
    tenant_id: Optional[str] = Field(
        None,
        alias='tenantId',
        description='Used to evaluate a condition for a tenant with the given id.\nWill only evaluate conditions of process definitions which belong to the tenant.',
    )
    without_tenant_id: Optional[bool] = Field(
        None,
        alias='withoutTenantId',
        description='A Boolean value that indicates whether the conditions should only be evaluated of process definitions which belong to no tenant or not.\nValue may only be true, as false is the default behavior.',
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='Used to evaluate conditions of the process definition with the given id.',
    )


class HistoricProcessInstanceQueryDto(BaseModel):
    """
    A historic process instance query which defines a group of historic process instances
    """

    class Config:
        allow_population_by_field_name = True

    process_instance_id: Optional[str] = Field(
        None, alias='processInstanceId', description='Filter by process instance id.'
    )
    process_instance_ids: Optional[Sequence[str]] = Field(
        None,
        alias='processInstanceIds',
        description='Filter by process instance ids. Must be a JSON array process instance ids.',
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='Filter by the process definition the instances run on.',
    )
    process_definition_key: Optional[str] = Field(
        None,
        alias='processDefinitionKey',
        description='Filter by the key of the process definition the instances run on.',
    )
    process_definition_key_in: Optional[Sequence[str]] = Field(
        None,
        alias='processDefinitionKeyIn',
        description='Filter by a list of process definition keys.\nA process instance must have one of the given process definition keys. Must be a JSON array of Strings.',
    )
    process_definition_name: Optional[str] = Field(
        None,
        alias='processDefinitionName',
        description='Filter by the name of the process definition the instances run on.',
    )
    process_definition_name_like: Optional[str] = Field(
        None,
        alias='processDefinitionNameLike',
        description='Filter by process definition names that the parameter is a substring of.',
    )
    process_definition_key_not_in: Optional[Sequence[str]] = Field(
        None,
        alias='processDefinitionKeyNotIn',
        description='Exclude instances that belong to a set of process definitions.\nMust be a JSON array of process definition keys.',
    )
    process_instance_business_key: Optional[str] = Field(
        None,
        alias='processInstanceBusinessKey',
        description='Filter by process instance business key.',
    )
    process_instance_business_key_like: Optional[str] = Field(
        None,
        alias='processInstanceBusinessKeyLike',
        description='Filter by process instance business key that the parameter is a substring of.',
    )
    root_process_instances: Optional[bool] = Field(
        None,
        alias='rootProcessInstances',
        description='Restrict the query to all process instances that are top level process instances.',
    )
    finished: Optional[bool] = Field(
        False,
        description='Only include finished process instances. Value may only be true, as false is the default behavior.',
    )
    unfinished: Optional[bool] = Field(
        False,
        description='Only include unfinished process instances. Value may only be true, as false is the default behavior.',
    )
    with_incidents: Optional[bool] = Field(
        False,
        alias='withIncidents',
        description='Only include process instances which have an incident. Value may only be true, as false is the default behavior.',
    )
    with_root_incidents: Optional[bool] = Field(
        'false',
        alias='withRootIncidents',
        description='Only include process instances which have a root incident. Value may only be true, as false is the default behavior.',
    )
    incident_type: Optional[str] = Field(
        None,
        alias='incidentType',
        description='Filter by the incident type.\nSee the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. ',
    )
    incident_status: Optional[IncidentStatus] = Field(
        None,
        alias='incidentStatus',
        description='Only include process instances which have an incident in status either open or resolved.\nTo get all process instances, use the query parameter withIncidents.',
    )
    incident_message: Optional[str] = Field(
        None,
        alias='incidentMessage',
        description='Filter by the incident message. Exact match.',
    )
    incident_message_like: Optional[str] = Field(
        None,
        alias='incidentMessageLike',
        description='Filter by the incident message that the parameter is a substring of.',
    )
    started_before: Optional[datetime] = Field(
        None,
        alias='startedBefore',
        description="Restrict to instances that were started before the given date.\nBy [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/),\nthe date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.",
    )
    started_after: Optional[datetime] = Field(
        None,
        alias='startedAfter',
        description="Restrict to instances that were started after the given date.\nBy [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/),\nthe date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.",
    )
    finished_before: Optional[datetime] = Field(
        None,
        alias='finishedBefore',
        description="Restrict to instances that were finished before the given date.\nBy [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/),\nthe date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.",
    )
    finished_after: Optional[datetime] = Field(
        None,
        alias='finishedAfter',
        description="Restrict to instances that were finished after the given date.\nBy [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/),\nthe date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.",
    )
    executed_activity_after: Optional[datetime] = Field(
        None,
        alias='executedActivityAfter',
        description="Restrict to instances that executed an activity after the given date (inclusive).\nBy [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/),\nthe date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.",
    )
    executed_activity_before: Optional[datetime] = Field(
        None,
        alias='executedActivityBefore',
        description="Restrict to instances that executed an activity before the given date (inclusive).\nBy [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/),\nthe date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.",
    )
    executed_job_after: Optional[datetime] = Field(
        None,
        alias='executedJobAfter',
        description="Restrict to instances that executed an job after the given date (inclusive).\nBy [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/),\nthe date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.",
    )
    executed_job_before: Optional[datetime] = Field(
        None,
        alias='executedJobBefore',
        description="Restrict to instances that executed an job before the given date (inclusive).\nBy [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/),\nthe date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.",
    )
    started_by: Optional[str] = Field(
        None,
        alias='startedBy',
        description='Only include process instances that were started by the given user.',
    )
    super_process_instance_id: Optional[str] = Field(
        None,
        alias='superProcessInstanceId',
        description='Restrict query to all process instances that are sub process instances of the given process instance.\nTakes a process instance id.',
    )
    sub_process_instance_id: Optional[str] = Field(
        None,
        alias='subProcessInstanceId',
        description='Restrict query to one process instance that has a sub process instance with the given id.',
    )
    super_case_instance_id: Optional[str] = Field(
        None,
        alias='superCaseInstanceId',
        description='Restrict query to all process instances that are sub process instances of the given case instance.\nTakes a case instance id.',
    )
    sub_case_instance_id: Optional[str] = Field(
        None,
        alias='subCaseInstanceId',
        description='Restrict query to one process instance that has a sub case instance with the given id.',
    )
    case_instance_id: Optional[str] = Field(
        None,
        alias='caseInstanceId',
        description='Restrict query to all process instances that are sub process instances of the given case instance.\nTakes a case instance id.',
    )
    tenant_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='tenantIdIn',
        description='Filter by a list of tenant ids. A process instance must have one of the given tenant ids.\nMust be a JSON array of Strings.',
    )
    without_tenant_id: Optional[bool] = Field(
        None,
        alias='withoutTenantId',
        description='Only include historic process instances which belong to no tenant.\nValue may only be true, as false is the default behavior.',
    )
    executed_activity_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='executedActivityIdIn',
        description='Restrict to instances that executed an activity with one of given ids.',
    )
    active_activity_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='activeActivityIdIn',
        description='Restrict to instances that have an active activity with one of given ids.',
    )
    active: Optional[bool] = Field(
        None, description='Restrict to instances that are active.'
    )
    suspended: Optional[bool] = Field(
        None, description='Restrict to instances that are suspended.'
    )
    completed: Optional[bool] = Field(
        None, description='Restrict to instances that are completed.'
    )
    externally_terminated: Optional[bool] = Field(
        None,
        alias='externallyTerminated',
        description='Restrict to instances that are externallyTerminated.',
    )
    internally_terminated: Optional[bool] = Field(
        None,
        alias='internallyTerminated',
        description='Restrict to instances that are internallyTerminated.',
    )
    variables: Optional[Sequence[VariableQueryParameterDto]] = Field(
        None,
        description='A JSON array to only include process instances that have/had variables with certain values.\nThe array consists of objects with the three properties `name`, `operator` and `value`.\n`name` (String) is the variable name,\n`operator` (String) is the comparison operator to be used and\n`value` the variable value.\n`value` may be String, Number or Boolean.\nValid operator values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to;\n`lt` - lower than; `lteq` - lower than or equal to; `like`.',
    )
    variable_names_ignore_case: Optional[bool] = Field(
        None,
        alias='variableNamesIgnoreCase',
        description='Match all variable names provided in variables case-insensitively.\nIf set to true variableName and variablename are treated as equal.',
    )
    variable_values_ignore_case: Optional[bool] = Field(
        None,
        alias='variableValuesIgnoreCase',
        description='Match all variable values provided in variables case-insensitively.\nIf set to true variableValue and variablevalue are treated as equal.',
    )
    or_queries: Optional[Sequence[HistoricProcessInstanceQueryDto]] = Field(
        None,
        alias='orQueries',
        description="A JSON array of nested historic process instance queries with OR semantics.\nA process instance matches a nested query if it fulfills at least one of the query's predicates.\nWith multiple nested queries, a process instance must fulfill at least one predicate of each query (Conjunctive Normal Form).\nAll process instance query properties can be used except for: sorting\nSee the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.",
    )
    sorting: Optional[Sequence[SortingItem2]] = Field(
        None, description='Apply sorting of the result'
    )


class LockedExternalTaskDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    activity_id: Optional[str] = Field(
        None,
        alias='activityId',
        description='The id of the activity that this external task belongs to.',
    )
    activity_instance_id: Optional[str] = Field(
        None,
        alias='activityInstanceId',
        description='The id of the activity instance that the external task belongs to.',
    )
    error_message: Optional[str] = Field(
        None,
        alias='errorMessage',
        description='The full error message submitted with the latest reported failure executing this task;`null` if no failure\nwas reported previously or if no error message was submitted',
    )
    error_details: Optional[str] = Field(
        None,
        alias='errorDetails',
        description='The error details submitted with the latest reported failure executing this task.`null` if no failure was\nreported previously or if no error details was submitted',
    )
    execution_id: Optional[str] = Field(
        None,
        alias='executionId',
        description='The id of the execution that the external task belongs to.',
    )
    id: Optional[str] = Field(None, description='The id of the external task.')
    lock_expiration_time: Optional[datetime] = Field(
        None,
        alias='lockExpirationTime',
        description="The date that the task's most recent lock expires or has expired.",
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='The id of the process definition the external task is defined in.',
    )
    process_definition_key: Optional[str] = Field(
        None,
        alias='processDefinitionKey',
        description='The key of the process definition the external task is defined in.',
    )
    process_definition_version_tag: Optional[str] = Field(
        None,
        alias='processDefinitionVersionTag',
        description='The version tag of the process definition the external task is defined in.',
    )
    process_instance_id: Optional[str] = Field(
        None,
        alias='processInstanceId',
        description='The id of the process instance the external task belongs to.',
    )
    tenant_id: Optional[str] = Field(
        None,
        alias='tenantId',
        description='The id of the tenant the external task belongs to.',
    )
    retries: Optional[int] = Field(
        None, description='The number of retries the task currently has left.'
    )
    suspended: Optional[bool] = Field(
        None,
        description='Whether the process instance the external task belongs to is suspended.',
    )
    worker_id: Optional[str] = Field(
        None,
        alias='workerId',
        description='The id of the worker that posesses or posessed the most recent lock.',
    )
    priority: Optional[int] = Field(
        None, description='The priority of the external task.'
    )
    topic_name: Optional[str] = Field(
        None, alias='topicName', description='The topic name of the external task.'
    )
    business_key: Optional[str] = Field(
        None,
        alias='businessKey',
        description='The business key of the process instance the external task belongs to.',
    )
    variables: Optional[Mapping[str, VariableValueDto]] = Field(
        None,
        description='A JSON object containing a property for each of the requested variables. The key is the variable name,\nthe value is a JSON object of serialized variable values with the following properties:',
    )


class MessageCorrelationResultWithVariableDto(BaseModel):
    """
        The `processInstance` property only has a value if the resultType is set to `ProcessDefinition`.
    The processInstance with the properties as described in the
    [get single instance](https://docs.camunda.org/manual/7.13/reference/rest/process-instance/get/) method.

    The `execution` property only has a value if the resultType is set to `Execution`.
    The execution with the properties as described in the
    [get single execution](https://docs.camunda.org/manual/7.13/reference/rest/execution/get/) method.
    """

    class Config:
        allow_population_by_field_name = True

    result_type: Optional[ResultType] = Field(
        None,
        alias='resultType',
        description='Indicates if the message was correlated to a message start event or an \nintermediate message catching event. In the first case, the resultType is \n`ProcessDefinition` and otherwise `Execution`.',
    )
    process_instance: Optional[ProcessInstanceDto] = Field(
        None, alias='processInstance'
    )
    execution: Optional[ExecutionDto] = None
    variables: Optional[Mapping[str, VariableValueDto]] = Field(
        None,
        description='This property is returned if the `variablesInResultEnabled` is set to `true`.\nContains a list of the process variables. ',
    )


class ParseExceptionDto(ExceptionDto):
    class Config:
        allow_population_by_field_name = True

    details: Optional[Mapping[str, ResourceReportDto]] = Field(
        None,
        description='A JSON Object containing list of errors and warnings occurred during deployment.',
    )


class PatchVariablesDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    modifications: Optional[Mapping[str, VariableValueDto]] = Field(
        None, description='A JSON object containing variable key-value pairs.'
    )
    deletions: Optional[Sequence[str]] = Field(
        None, description='An array of String keys of variables to be deleted.'
    )


class ProcessInstanceQueryDto(BaseModel):
    """
    A process instance query which defines a group of process instances
    """

    class Config:
        allow_population_by_field_name = True

    deployment_id: Optional[str] = Field(
        None,
        alias='deploymentId',
        description='Filter by the deployment the id belongs to.',
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='Filter by the process definition the instances run on.',
    )
    process_definition_key: Optional[str] = Field(
        None,
        alias='processDefinitionKey',
        description='Filter by the key of the process definition the instances run on.',
    )
    process_definition_key_in: Optional[Sequence[str]] = Field(
        None,
        alias='processDefinitionKeyIn',
        description='Filter by a list of process definition keys.\nA process instance must have one of the given process definition keys. Must be a JSON array of Strings.',
    )
    process_definition_key_not_in: Optional[Sequence[str]] = Field(
        None,
        alias='processDefinitionKeyNotIn',
        description='Exclude instances by a list of process definition keys.\nA process instance must not have one of the given process definition keys. Must be a JSON array of Strings.',
    )
    business_key: Optional[str] = Field(
        None,
        alias='businessKey',
        description='Filter by process instance business key.',
    )
    business_key_like: Optional[str] = Field(
        None,
        alias='businessKeyLike',
        description='Filter by process instance business key that the parameter is a substring of.',
    )
    case_instance_id: Optional[str] = Field(
        None, alias='caseInstanceId', description='Filter by case instance id.'
    )
    super_process_instance: Optional[str] = Field(
        None,
        alias='superProcessInstance',
        description='Restrict query to all process instances that are sub process instances of the given process instance.\nTakes a process instance id.',
    )
    sub_process_instance: Optional[str] = Field(
        None,
        alias='subProcessInstance',
        description='Restrict query to all process instances that have the given process instance as a sub process instance.\nTakes a process instance id.',
    )
    super_case_instance: Optional[str] = Field(
        None,
        alias='superCaseInstance',
        description='Restrict query to all process instances that are sub process instances of the given case instance.\nTakes a case instance id.',
    )
    sub_case_instance: Optional[str] = Field(
        None,
        alias='subCaseInstance',
        description='Restrict query to all process instances that have the given case instance as a sub case instance.\nTakes a case instance id.',
    )
    active: Optional[bool] = Field(
        None,
        description='Only include active process instances. Value may only be true, as false is the default behavior.',
    )
    suspended: Optional[bool] = Field(
        None,
        description='Only include suspended process instances. Value may only be true, as false is the default behavior.',
    )
    process_instance_ids: Optional[Sequence[str]] = Field(
        None,
        alias='processInstanceIds',
        description='Filter by a list of process instance ids. Must be a JSON array of Strings.',
    )
    with_incident: Optional[bool] = Field(
        None,
        alias='withIncident',
        description='Filter by presence of incidents. Selects only process instances that have an incident.',
    )
    incident_id: Optional[str] = Field(
        None, alias='incidentId', description='Filter by the incident id.'
    )
    incident_type: Optional[str] = Field(
        None,
        alias='incidentType',
        description='Filter by the incident type. See the User Guide for a list of incident types.',
    )
    incident_message: Optional[str] = Field(
        None,
        alias='incidentMessage',
        description='Filter by the incident message. Exact match.',
    )
    incident_message_like: Optional[str] = Field(
        None,
        alias='incidentMessageLike',
        description='Filter by the incident message that the parameter is a substring of.',
    )
    tenant_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='tenantIdIn',
        description='Filter by a list of tenant ids. A process instance must have one of the given tenant ids.\nMust be a JSON array of Strings.',
    )
    without_tenant_id: Optional[bool] = Field(
        None,
        alias='withoutTenantId',
        description='Only include process instances which belong to no tenant.\nValue may only be true, as false is the default behavior.',
    )
    process_definition_without_tenant_id: Optional[bool] = Field(
        None,
        alias='processDefinitionWithoutTenantId',
        description='Only include process instances which process definition has no tenant id.',
    )
    activity_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='activityIdIn',
        description='Filter by a list of activity ids.\nA process instance must currently wait in a leaf activity with one of the given activity ids.',
    )
    root_process_instances: Optional[bool] = Field(
        None,
        alias='rootProcessInstances',
        description='Restrict the query to all process instances that are top level process instances.',
    )
    leaf_process_instances: Optional[bool] = Field(
        None,
        alias='leafProcessInstances',
        description="Restrict the query to all process instances that are leaf instances. (i.e. don't have any sub instances)",
    )
    variables: Optional[Sequence[VariableQueryParameterDto]] = Field(
        None,
        description='A JSON array to only include process instances that have variables with certain values.\nThe array consists of objects with the three properties `name`, `operator` and `value`.\n`name` (String) is the variable name,\n`operator` (String) is the comparison operator to be used and `value` the variable value.\nThe `value` may be String, Number or Boolean.\n\nValid operator values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than;\n`gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`.',
    )
    variable_names_ignore_case: Optional[bool] = Field(
        None,
        alias='variableNamesIgnoreCase',
        description='Match all variable names in this query case-insensitively.\nIf set to true variableName and variablename are treated as equal.',
    )
    variable_values_ignore_case: Optional[bool] = Field(
        None,
        alias='variableValuesIgnoreCase',
        description='Match all variable values in this query case-insensitively.\nIf set to true variableValue and variablevalue are treated as equal.',
    )
    or_queries: Optional[Sequence[ProcessInstanceQueryDto]] = Field(
        None,
        alias='orQueries',
        description="A JSON array of nested process instance queries with OR semantics.\nA process instance matches a nested query if it fulfills at least one of the query's predicates.\nWith multiple nested queries, a process instance must fulfill at least one predicate of each query (Conjunctive Normal Form).\nAll process instance query properties can be used except for: `sorting`\nSee the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.",
    )
    sorting: Optional[Sequence[SortingItem3]] = Field(
        None, description='Apply sorting of the result'
    )


class ProcessInstanceSuspensionStateAsyncDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    suspended: Optional[bool] = Field(
        None,
        description='A Boolean value which indicates whether to activate or suspend a given process instance.\nWhen the value is set to true, the given process instance will be suspended and when the value is set to false,\nthe given process instance will be activated.',
    )
    process_instance_ids: Optional[Sequence[str]] = Field(
        None,
        alias='processInstanceIds',
        description='A list of process instance ids which defines a group of process instances\nwhich will be activated or suspended by the operation.',
    )
    process_instance_query: Optional[ProcessInstanceQueryDto] = Field(
        None, alias='processInstanceQuery'
    )
    historic_process_instance_query: Optional[HistoricProcessInstanceQueryDto] = Field(
        None, alias='historicProcessInstanceQuery'
    )


class ProcessInstanceSuspensionStateDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    suspended: Optional[bool] = Field(
        None,
        description='A `Boolean` value which indicates whether to activate or suspend a given process instance.\nWhen the value is set to `true`, the given process instance will be suspended and when the value is set to `false`,\nthe given process instance will be activated.',
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='The process definition id of the process instances to activate or suspend.\n\n**Note**: This parameter can be used only with combination of `suspended`.',
    )
    process_definition_key: Optional[str] = Field(
        None,
        alias='processDefinitionKey',
        description='The process definition key of the process instances to activate or suspend.\n\n**Note**: This parameter can be used only with combination of `suspended`, `processDefinitionTenantId`, and `processDefinitionWithoutTenantId`.',
    )
    process_definition_tenant_id: Optional[str] = Field(
        None,
        alias='processDefinitionTenantId',
        description='Only activate or suspend process instances of a process definition which belongs to a tenant with the given id.\n\n**Note**: This parameter can be used only with combination of `suspended`, `processDefinitionKey`, and `processDefinitionWithoutTenantId`.',
    )
    process_definition_without_tenant_id: Optional[bool] = Field(
        None,
        alias='processDefinitionWithoutTenantId',
        description='Only activate or suspend process instances of a process definition which belongs to no tenant.\nValue may only be true, as false is the default behavior.\n\n**Note**: This parameter can be used only with combination of `suspended`, `processDefinitionKey`, and `processDefinitionTenantId`.',
    )
    process_instance_ids: Optional[Sequence[str]] = Field(
        None,
        alias='processInstanceIds',
        description='A list of process instance ids which defines a group of process instances\nwhich will be activated or suspended by the operation.\n\n**Note**: This parameter can be used only with combination of `suspended`, `processInstanceQuery`, and `historicProcessInstanceQuery`.',
    )
    process_instance_query: Optional[ProcessInstanceQueryDto] = Field(
        None, alias='processInstanceQuery'
    )
    historic_process_instance_query: Optional[HistoricProcessInstanceQueryDto] = Field(
        None, alias='historicProcessInstanceQuery'
    )


class ProcessInstanceWithVariablesDto(ProcessInstanceDto):
    class Config:
        allow_population_by_field_name = True

    variables: Optional[Mapping[str, VariableValueDto]] = Field(
        None, description='The id of the process instance.'
    )


class RestartProcessInstanceDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    process_instance_ids: Optional[Sequence[str]] = Field(
        None,
        alias='processInstanceIds',
        description='A list of process instance ids to restart.',
    )
    historic_process_instance_query: Optional[HistoricProcessInstanceQueryDto] = Field(
        None, alias='historicProcessInstanceQuery'
    )
    skip_custom_listeners: Optional[bool] = Field(
        None,
        alias='skipCustomListeners',
        description='Skip execution listener invocation for activities that are started as part of this request.',
    )
    skip_io_mappings: Optional[bool] = Field(
        None,
        alias='skipIoMappings',
        description='Skip execution of\n[input/output variable mappings](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/#input-output-variable-mapping)\nfor activities that are started as part of this request.',
    )
    initial_variables: Optional[bool] = Field(
        None,
        alias='initialVariables',
        description='Set the initial set of variables during restart. By default, the last set of variables is used.',
    )
    without_business_key: Optional[bool] = Field(
        None,
        alias='withoutBusinessKey',
        description='Do not take over the business key of the historic process instance.',
    )
    instructions: Optional[
        Sequence[RestartProcessInstanceModificationInstructionDto]
    ] = Field(
        None,
        description='**Optional**. A JSON array of instructions that specify which activities to start the process instance at.\nIf this property is omitted, the process instance starts at its default blank start event.',
    )


class SetJobRetriesByProcessDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    process_instances: Optional[Sequence[str]] = Field(
        None,
        alias='processInstances',
        description='A list of process instance ids to fetch jobs, for which retries will be set.',
    )
    retries: Optional[conint(ge=0)] = Field(
        None,
        description='An integer representing the number of retries. Please note that the value cannot be negative or null.',
    )
    process_instance_query: Optional[ProcessInstanceQueryDto] = Field(
        None, alias='processInstanceQuery'
    )
    historic_process_instance_query: Optional[HistoricProcessInstanceQueryDto] = Field(
        None, alias='historicProcessInstanceQuery'
    )


class SetRetriesForExternalTasksDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    retries: Optional[int] = Field(
        None,
        description='The number of retries to set for the external task.  Must be >= 0. If this is 0, an incident is created\nand the task cannot be fetched anymore unless the retries are increased again. Can not be null.',
    )
    external_task_ids: Optional[Sequence[str]] = Field(
        None,
        alias='externalTaskIds',
        description='The ids of the external tasks to set the number of retries for.',
    )
    process_instance_ids: Optional[Sequence[str]] = Field(
        None,
        alias='processInstanceIds',
        description='The ids of process instances containing the tasks to set the number of retries for.',
    )
    external_task_query: Optional[ExternalTaskQueryDto] = Field(
        None, alias='externalTaskQuery'
    )
    process_instance_query: Optional[ProcessInstanceQueryDto] = Field(
        None, alias='processInstanceQuery'
    )
    historic_process_instance_query: Optional[HistoricProcessInstanceQueryDto] = Field(
        None, alias='historicProcessInstanceQuery'
    )


class SignalDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[str] = Field(
        None,
        description='The name of the signal to deliver.\n\n**Note**: This property is mandatory.',
    )
    execution_id: Optional[str] = Field(
        None,
        alias='executionId',
        description='Optionally specifies a single execution which is notified by the signal.\n\n**Note**: If no execution id is defined the signal is broadcasted to all subscribed\nhandlers. ',
    )
    variables: Optional[Mapping[str, VariableValueDto]] = Field(
        None,
        description='A JSON object containing variable key-value pairs. Each key is a variable name and\neach value a JSON variable value object.',
    )
    tenant_id: Optional[str] = Field(
        None,
        alias='tenantId',
        description='Specifies a tenant to deliver the signal. The signal can only be received on\nexecutions or process definitions which belongs to the given tenant.\n\n**Note**: Cannot be used in combination with executionId.',
    )
    without_tenant_id: Optional[bool] = Field(
        None,
        alias='withoutTenantId',
        description='If true the signal can only be received on executions or process definitions which\nbelongs to no tenant. Value may not be false as this is the default behavior.\n\n**Note**: Cannot be used in combination with `executionId`.',
    )


class StartProcessInstanceFormDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    variables: Optional[Mapping[str, VariableValueDto]] = Field(None, description='')
    business_key: Optional[str] = Field(
        None,
        alias='businessKey',
        description='The business key the process instance is to be initialized with.\nThe business key uniquely identifies the process instance in the context of the given process definition.',
    )


class TaskBpmnErrorDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    error_code: Optional[str] = Field(
        None,
        alias='errorCode',
        description='An error code that indicates the predefined error. It is used to identify the BPMN\nerror handler.',
    )
    error_message: Optional[str] = Field(
        None,
        alias='errorMessage',
        description='An error message that describes the error.',
    )
    variables: Optional[Mapping[str, VariableValueDto]] = Field(
        None, description='A JSON object containing variable key-value pairs.'
    )


class TaskEscalationDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    escalation_code: Optional[str] = Field(
        None,
        alias='escalationCode',
        description='An escalation code that indicates the predefined escalation. It is used to identify\nthe BPMN escalation handler.',
    )
    variables: Optional[Mapping[str, VariableValueDto]] = Field(
        None, description='A JSON object containing variable key-value pairs.'
    )


class TaskQueryDto(BaseModel):
    """
    A Task query which defines a group of Tasks.
    """

    class Config:
        allow_population_by_field_name = True

    process_instance_id: Optional[str] = Field(
        None,
        alias='processInstanceId',
        description='Restrict to tasks that belong to process instances with the given id.',
    )
    process_instance_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='processInstanceIdIn',
        description='Restrict to tasks that belong to process instances with the given ids.',
    )
    process_instance_business_key: Optional[str] = Field(
        None,
        alias='processInstanceBusinessKey',
        description='Restrict to tasks that belong to process instances with the given business key.',
    )
    process_instance_business_key_expression: Optional[str] = Field(
        None,
        alias='processInstanceBusinessKeyExpression',
        description='Restrict to tasks that belong to process instances with the given business key which \nis described by an expression. See the \n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions.',
    )
    process_instance_business_key_in: Optional[Sequence[str]] = Field(
        None,
        alias='processInstanceBusinessKeyIn',
        description='Restrict to tasks that belong to process instances with one of the give business keys. \nThe keys need to be in a comma-separated list.',
    )
    process_instance_business_key_like: Optional[str] = Field(
        None,
        alias='processInstanceBusinessKeyLike',
        description='Restrict to tasks that have a process instance business key that has the parameter \nvalue as a substring.',
    )
    process_instance_business_key_like_expression: Optional[str] = Field(
        None,
        alias='processInstanceBusinessKeyLikeExpression',
        description='Restrict to tasks that have a process instance business key that has the parameter \nvalue as a substring and is described by an expression. See the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.',
    )
    process_definition_id: Optional[str] = Field(
        None,
        alias='processDefinitionId',
        description='Restrict to tasks that belong to a process definition with the given id.',
    )
    process_definition_key: Optional[str] = Field(
        None,
        alias='processDefinitionKey',
        description='Restrict to tasks that belong to a process definition with the given key.',
    )
    process_definition_key_in: Optional[Sequence[str]] = Field(
        None,
        alias='processDefinitionKeyIn',
        description='Restrict to tasks that belong to a process definition with one of the given keys. The \nkeys need to be in a comma-separated list.',
    )
    process_definition_name: Optional[str] = Field(
        None,
        alias='processDefinitionName',
        description='Restrict to tasks that belong to a process definition with the given name.',
    )
    process_definition_name_like: Optional[str] = Field(
        None,
        alias='processDefinitionNameLike',
        description='Restrict to tasks that have a process definition name that has the parameter value as \na substring.',
    )
    execution_id: Optional[str] = Field(
        None,
        alias='executionId',
        description='Restrict to tasks that belong to an execution with the given id.',
    )
    case_instance_id: Optional[str] = Field(
        None,
        alias='caseInstanceId',
        description='Restrict to tasks that belong to case instances with the given id.',
    )
    case_instance_business_key: Optional[str] = Field(
        None,
        alias='caseInstanceBusinessKey',
        description='Restrict to tasks that belong to case instances with the given business key.',
    )
    case_instance_business_key_like: Optional[str] = Field(
        None,
        alias='caseInstanceBusinessKeyLike',
        description='Restrict to tasks that have a case instance business key that has the parameter value \nas a substring.',
    )
    case_definition_id: Optional[str] = Field(
        None,
        alias='caseDefinitionId',
        description='Restrict to tasks that belong to a case definition with the given id.',
    )
    case_definition_key: Optional[str] = Field(
        None,
        alias='caseDefinitionKey',
        description='Restrict to tasks that belong to a case definition with the given key.',
    )
    case_definition_name: Optional[str] = Field(
        None,
        alias='caseDefinitionName',
        description='Restrict to tasks that belong to a case definition with the given name.',
    )
    case_definition_name_like: Optional[str] = Field(
        None,
        alias='caseDefinitionNameLike',
        description='Restrict to tasks that have a case definition name that has the parameter value as a \nsubstring.',
    )
    case_execution_id: Optional[str] = Field(
        None,
        alias='caseExecutionId',
        description='Restrict to tasks that belong to a case execution with the given id.',
    )
    activity_instance_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='activityInstanceIdIn',
        description='Only include tasks which belong to one of the passed and comma-separated activity \ninstance ids.',
    )
    tenant_id_in: Optional[Sequence[str]] = Field(
        None,
        alias='tenantIdIn',
        description='Only include tasks which belong to one of the passed and comma-separated \ntenant ids.',
    )
    without_tenant_id: Optional[bool] = Field(
        False,
        alias='withoutTenantId',
        description='Only include tasks which belong to no tenant. Value may only be `true`, \nas `false` is the default behavior.',
    )
    assignee: Optional[str] = Field(
        None, description='Restrict to tasks that the given user is assigned to.'
    )
    assignee_expression: Optional[str] = Field(
        None,
        alias='assigneeExpression',
        description='Restrict to tasks that the user described by the given expression is assigned to. See the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.',
    )
    assignee_like: Optional[str] = Field(
        None,
        alias='assigneeLike',
        description='Restrict to tasks that have an assignee that has the parameter \nvalue as a substring.',
    )
    assignee_like_expression: Optional[str] = Field(
        None,
        alias='assigneeLikeExpression',
        description='Restrict to tasks that have an assignee that has the parameter value described by the \ngiven expression as a substring. See the \n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.',
    )
    assignee_in: Optional[Sequence[str]] = Field(
        None,
        alias='assigneeIn',
        description='Only include tasks which are assigned to one of the passed and comma-separated user ids.',
    )
    owner: Optional[str] = Field(
        None, description='Restrict to tasks that the given user owns.'
    )
    owner_expression: Optional[str] = Field(
        None,
        alias='ownerExpression',
        description='Restrict to tasks that the user described by the given expression owns. See the \n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.',
    )
    candidate_group: Optional[str] = Field(
        None,
        alias='candidateGroup',
        description='Only include tasks that are offered to the given group.',
    )
    candidate_group_expression: Optional[str] = Field(
        None,
        alias='candidateGroupExpression',
        description='Only include tasks that are offered to the group described by the given expression. \nSee the \n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.',
    )
    candidate_user: Optional[str] = Field(
        None,
        alias='candidateUser',
        description='Only include tasks that are offered to the given user or to one of his groups.',
    )
    candidate_user_expression: Optional[str] = Field(
        None,
        alias='candidateUserExpression',
        description='Only include tasks that are offered to the user described by the given expression. \nSee the \n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) \nfor more information on available functions.',
    )
    include_assigned_tasks: Optional[bool] = Field(
        False,
        alias='includeAssignedTasks',
        description='Also include tasks that are assigned to users in candidate queries. Default is to only \ninclude tasks that are not assigned to any user if you query by candidate user or\ngroup(s).',
    )
    involved_user: Optional[str] = Field(
        None,
        alias='involvedUser',
        description='Only include tasks that the given user is involved in. A user is involved in a task if \nan identity link exists between task and user (e.g., the user is the assignee).',
    )
    involved_user_expression: Optional[str] = Field(
        None,
        alias='involvedUserExpression',
        description='Only include tasks that the user described by the given expression is involved in.\nA user is involved in a task if an identity link exists between task and user\n(e.g., the user is the assignee). See the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions.',
    )
    assigned: Optional[bool] = Field(
        False,
        description='If set to `true`, restricts the query to all tasks that are assigned.',
    )
    unassigned: Optional[bool] = Field(
        False,
        description='If set to `true`, restricts the query to all tasks that are unassigned.',
    )
    task_definition_key: Optional[str] = Field(
        None,
        alias='taskDefinitionKey',
        description='Restrict to tasks that have the given key.',
    )
    task_definition_key_in: Optional[Sequence[str]] = Field(
        None,
        alias='taskDefinitionKeyIn',
        description='Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.',
    )
    task_definition_key_like: Optional[str] = Field(
        None,
        alias='taskDefinitionKeyLike',
        description='Restrict to tasks that have a key that has the parameter value as a substring.',
    )
    name: Optional[str] = Field(
        None, description='Restrict to tasks that have the given name.'
    )
    name_not_equal: Optional[str] = Field(
        None,
        alias='nameNotEqual',
        description='Restrict to tasks that do not have the given name.',
    )
    name_like: Optional[str] = Field(
        None,
        alias='nameLike',
        description='Restrict to tasks that have a name with the given parameter value as substring.',
    )
    name_not_like: Optional[str] = Field(
        None,
        alias='nameNotLike',
        description='Restrict to tasks that do not have a name with the given parameter\nvalue as substring.',
    )
    description: Optional[str] = Field(
        None, description='Restrict to tasks that have the given description.'
    )
    description_like: Optional[str] = Field(
        None,
        alias='descriptionLike',
        description='Restrict to tasks that have a description that has the parameter\nvalue as a substring.',
    )
    priority: Optional[int] = Field(
        None, description='Restrict to tasks that have the given priority.'
    )
    max_priority: Optional[int] = Field(
        None,
        alias='maxPriority',
        description='Restrict to tasks that have a lower or equal priority.',
    )
    min_priority: Optional[int] = Field(
        None,
        alias='minPriority',
        description='Restrict to tasks that have a higher or equal priority.',
    )
    due_date: Optional[datetime] = Field(
        None,
        alias='dueDate',
        description="Restrict to tasks that are due on the given date. By\n[default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format\n`yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.546+0200`.",
    )
    due_date_expression: Optional[str] = Field(
        None,
        alias='dueDateExpression',
        description='Restrict to tasks that are due on the date described by the given expression. See the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.',
    )
    due_after: Optional[datetime] = Field(
        None,
        alias='dueAfter',
        description="Restrict to tasks that are due after the given date. By\n[default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.435+0200`.",
    )
    due_after_expression: Optional[str] = Field(
        None,
        alias='dueAfterExpression',
        description='Restrict to tasks that are due after the date described by the given expression.\nSee the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.',
    )
    due_before: Optional[datetime] = Field(
        None,
        alias='dueBefore',
        description="Restrict to tasks that are due before the given date. By\n[default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.243+0200`.",
    )
    due_before_expression: Optional[str] = Field(
        None,
        alias='dueBeforeExpression',
        description='Restrict to tasks that are due before the date described by the given expression.\nSee the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.',
    )
    follow_up_date: Optional[datetime] = Field(
        None,
        alias='followUpDate',
        description="Restrict to tasks that have a followUp date on the given date. By\n[default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date\nmust have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.342+0200`.",
    )
    follow_up_date_expression: Optional[str] = Field(
        None,
        alias='followUpDateExpression',
        description='Restrict to tasks that have a followUp date on the date described by the given\nexpression. See the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.',
    )
    follow_up_after: Optional[datetime] = Field(
        None,
        alias='followUpAfter',
        description="Restrict to tasks that have a followUp date after the given date. By\n[default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.542+0200`.",
    )
    follow_up_after_expression: Optional[str] = Field(
        None,
        alias='followUpAfterExpression',
        description='Restrict to tasks that have a followUp date after the date described by the given\nexpression. See the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.',
    )
    follow_up_before: Optional[str] = Field(
        None,
        alias='followUpBefore',
        description="Restrict to tasks that have a followUp date before the given date. By\n[default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.234+0200`.",
    )
    follow_up_before_expression: Optional[str] = Field(
        None,
        alias='followUpBeforeExpression',
        description='Restrict to tasks that have a followUp date before the date described by the given\nexpression. See the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.',
    )
    follow_up_before_or_not_existent: Optional[datetime] = Field(
        None,
        alias='followUpBeforeOrNotExistent',
        description="Restrict to tasks that have no followUp date or a followUp date before the given date.\nBy [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.432+0200`. The typical use case\nis to query all `active` tasks for a user for a given date.",
    )
    follow_up_before_or_not_existent_expression: Optional[str] = Field(
        None,
        alias='followUpBeforeOrNotExistentExpression',
        description='Restrict to tasks that have no followUp date or a followUp date before the date\ndescribed by the given expression. See the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.',
    )
    created_on: Optional[datetime] = Field(
        None,
        alias='createdOn',
        description="Restrict to tasks that were created on the given date. By\n[default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have\nthe format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.324+0200`.",
    )
    created_on_expression: Optional[str] = Field(
        None,
        alias='createdOnExpression',
        description='Restrict to tasks that were created on the date described by the given expression.\nSee the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.',
    )
    created_after: Optional[datetime] = Field(
        None,
        alias='createdAfter',
        description="Restrict to tasks that were created after the given date. By\n[default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must\nhave the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.342+0200`.",
    )
    created_after_expression: Optional[str] = Field(
        None,
        alias='createdAfterExpression',
        description='Restrict to tasks that were created after the date described by the given expression.\nSee the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.',
    )
    created_before: Optional[datetime] = Field(
        None,
        alias='createdBefore',
        description="Restrict to tasks that were created before the given date. By\n[default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must\nhave the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.332+0200`.",
    )
    created_before_expression: Optional[str] = Field(
        None,
        alias='createdBeforeExpression',
        description='Restrict to tasks that were created before the date described by the given expression.\nSee the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to a\n`java.util.Date` or `org.joda.time.DateTime` object.',
    )
    delegation_state: Optional[DelegationState] = Field(
        None,
        alias='delegationState',
        description='Restrict to tasks that are in the given delegation state. Valid values are\n`PENDING` and `RESOLVED`.',
    )
    candidate_groups: Optional[Sequence[str]] = Field(
        None,
        alias='candidateGroups',
        description='Restrict to tasks that are offered to any of the given candidate groups. Takes a\ncomma-separated list of group names, so for example\n`developers,support,sales`.',
    )
    candidate_groups_expression: Optional[str] = Field(
        None,
        alias='candidateGroupsExpression',
        description='Restrict to tasks that are offered to any of the candidate groups described by the\ngiven expression. See the\n[user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)\nfor more information on available functions. The expression must evaluate to\n`java.util.List` of Strings.',
    )
    with_candidate_groups: Optional[bool] = Field(
        False,
        alias='withCandidateGroups',
        description='Only include tasks which have a candidate group. Value may only be `true`,\nas `false` is the default behavior.',
    )
    without_candidate_groups: Optional[bool] = Field(
        False,
        alias='withoutCandidateGroups',
        description='Only include tasks which have no candidate group. Value may only be `true`,\nas `false` is the default behavior.',
    )
    with_candidate_users: Optional[bool] = Field(
        False,
        alias='withCandidateUsers',
        description='Only include tasks which have a candidate user. Value may only be `true`,\nas `false` is the default behavior.',
    )
    without_candidate_users: Optional[bool] = Field(
        False,
        alias='withoutCandidateUsers',
        description='Only include tasks which have no candidate users. Value may only be `true`,\nas `false` is the default behavior.',
    )
    active: Optional[bool] = Field(
        False,
        description='Only include active tasks. Value may only be `true`, as `false`\nis the default behavior.',
    )
    suspended: Optional[bool] = Field(
        False,
        description='Only include suspended tasks. Value may only be `true`, as\n`false` is the default behavior.',
    )
    task_variables: Optional[Sequence[VariableQueryParameterDto]] = Field(
        None,
        alias='taskVariables',
        description='A JSON array to only include tasks that have variables with certain values. The\narray consists of JSON objects with three properties `name`, `operator` and `value`.\n`name` is the variable name, `operator` is the comparison operator to be used and\n`value` the variable value. `value` may be of type `String`, `Number` or `Boolean`.\n\nValid `operator` values are:\n`eq` - equal to;\n`neq` - not equal to;\n`gt` - greater than;\n`gteq` - greater than or equal to;\n`lt` - lower than;\n`lteq` - lower than or equal to;\n`like`.\n`key` and `value` may not contain underscore or comma characters.',
    )
    process_variables: Optional[Sequence[VariableQueryParameterDto]] = Field(
        None,
        alias='processVariables',
        description='A JSON array to only include tasks that belong to a process instance with variables\nwith certain values. The array consists of JSON objects with three properties\n`name`, `operator` and `value`. `name` is the variable name, `operator` is the\ncomparison operator to be used and `value` the variable value. `value` may be of\ntype `String`, `Number` or `Boolean`.\n\nValid `operator` values are:\n`eq` - equal to;\n`neq` - not equal to;\n`gt` - greater than;\n`gteq` - greater than or equal to;\n`lt` - lower than;\n`lteq` - lower than or equal to;\n`like`.\n`key` and `value` may not contain underscore or comma characters.',
    )
    case_instance_variables: Optional[Sequence[VariableQueryParameterDto]] = Field(
        None,
        alias='caseInstanceVariables',
        description='A JSON array to only include tasks that belong to a case instance with variables\nwith certain values. The array consists of JSON objects with three properties\n`name`, `operator` and `value`. `name` is the variable name, `operator` is the\ncomparison operator to be used and `value` the variable value. `value` may be of\ntype `String`, `Number` or `Boolean`.\n\nValid `operator` values are:\n`eq` - equal to;\n`neq` - not equal to;\n`gt` - greater than;\n`gteq` - greater than or equal to;\n`lt` - lower than;\n`lteq` - lower than or equal to;\n`like`.\n`key` and `value` may not contain underscore or comma characters.',
    )
    variable_names_ignore_case: Optional[bool] = Field(
        False,
        alias='variableNamesIgnoreCase',
        description='Match all variable names in this query case-insensitively. If set\n`variableName` and `variablename` are treated as equal.',
    )
    variable_values_ignore_case: Optional[bool] = Field(
        False,
        alias='variableValuesIgnoreCase',
        description='Match all variable values in this query case-insensitively. If set\n`variableValue` and `variablevalue` are treated as equal.',
    )
    parent_task_id: Optional[str] = Field(
        None,
        alias='parentTaskId',
        description='Restrict query to all tasks that are sub tasks of the given task. Takes a task id.',
    )
    or_queries: Optional[Sequence[TaskQueryDto]] = Field(
        None,
        alias='orQueries',
        description="A JSON array of nested task queries with OR semantics. A task matches a nested query if it fulfills\n*at least one* of the query's predicates. With multiple nested queries, a task must fulfill at least one predicate of *each* query ([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).\n\nAll task query properties can be used except for: `sorting`, `withCandidateGroups`,\n`withoutCandidateGroups`, `withCandidateUsers`, `withoutCandidateUsers`\n\nSee the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-engine-api/#or-queries)\nfor more information about OR queries.",
    )
    sorting: Optional[Sequence[SortingItem5]] = Field(
        None, description='Apply sorting of the result'
    )


class TriggerVariableValueDto(VariableValueDto):
    class Config:
        allow_population_by_field_name = True

    local: Optional[bool] = Field(
        None,
        description='Indicates whether the variable should be a local variable or not.\nIf set to true, the variable becomes a local variable of the execution\nentering the target activity.',
    )


class DeleteProcessInstancesDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    process_instance_ids: Optional[Sequence[str]] = Field(
        None,
        alias='processInstanceIds',
        description='A list process instance ids to delete.',
    )
    delete_reason: Optional[str] = Field(
        None, alias='deleteReason', description='A string with delete reason.'
    )
    skip_custom_listeners: Optional[bool] = Field(
        None,
        alias='skipCustomListeners',
        description='Skip execution listener invocation for activities that are started or ended as part of this request.',
    )
    skip_subprocesses: Optional[bool] = Field(
        None,
        alias='skipSubprocesses',
        description='Skip deletion of the subprocesses related to deleted processes as part of this request.',
    )
    process_instance_query: Optional[ProcessInstanceQueryDto] = Field(
        None, alias='processInstanceQuery'
    )
    historic_process_instance_query: Optional[HistoricProcessInstanceQueryDto] = Field(
        None, alias='historicProcessInstanceQuery'
    )


class ExternalTaskBpmnError(TaskBpmnErrorDto):
    class Config:
        allow_population_by_field_name = True

    worker_id: Optional[str] = Field(
        None,
        alias='workerId',
        description='The id of the worker that reports the failure. Must match the id of the worker who has most recently\nlocked the task.',
    )


class ProcessInstanceModificationInstructionDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    type: Type = Field(
        ...,
        description='**Mandatory**. One of the following values: `cancel`, `startBeforeActivity`, `startAfterActivity`, `startTransition`.\n\n* A cancel instruction requests cancellation of a single activity instance or all instances of one activity.\n* A startBeforeActivity instruction requests to enter a given activity.\n* A startAfterActivity instruction requests to execute the single outgoing sequence flow of a given activity.\n* A startTransition instruction requests to execute a specific sequence flow.',
    )
    variables: Optional[TriggerVariableValueDto] = None
    activity_id: Optional[str] = Field(
        None,
        alias='activityId',
        description='Can be used with instructions of types `startTransition`. Specifies the sequence flow to start.',
    )
    transition_id: Optional[str] = Field(
        None,
        alias='transitionId',
        description='Can be used with instructions of types `startTransition`. Specifies the sequence flow to start.',
    )
    activity_instance_id: Optional[str] = Field(
        None,
        alias='activityInstanceId',
        description='Can be used with instructions of type `cancel`. Specifies the activity instance to cancel.\nValid values are the activity instance IDs supplied by the [Get Activity Instance request](https://docs.camunda.org/manual/7.13/reference/rest/process-instance/get-activity-instances/).',
    )
    transition_instance_id: Optional[str] = Field(
        None,
        alias='transitionInstanceId',
        description='Can be used with instructions of type `cancel`. Specifies the transition instance to cancel.\nValid values are the transition instance IDs supplied by the [Get Activity Instance request](https://docs.camunda.org/manual/7.13/reference/rest/process-instance/get-activity-instances/).',
    )
    ancestor_activity_instance_id: Optional[str] = Field(
        None,
        alias='ancestorActivityInstanceId',
        description='Can be used with instructions of type `startBeforeActivity`, `startAfterActivity`, and `startTransition`.\nValid values are the activity instance IDs supplied by the Get Activity Instance request.\nIf there are multiple parent activity instances of the targeted activity,\nthis specifies the ancestor scope in which hierarchy the activity/transition is to be instantiated.\n\nExample: When there are two instances of a subprocess and an activity contained in the subprocess is to be started,\nthis parameter allows to specifiy under which subprocess instance the activity should be started.',
    )
    cancel_current_active_activity_instances: Optional[bool] = Field(
        None,
        alias='cancelCurrentActiveActivityInstances',
        description='Can be used with instructions of type cancel. Prevents the deletion of new created activity instances.',
    )


class StartProcessInstanceDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    business_key: Optional[str] = Field(
        None,
        alias='businessKey',
        description='The business key of the process instance.',
    )
    variables: Optional[Mapping[str, VariableValueDto]] = Field(None, description='')
    case_instance_id: Optional[str] = Field(
        None,
        alias='caseInstanceId',
        description='The case instance id the process instance is to be initialized with.',
    )
    start_instructions: Optional[
        Sequence[ProcessInstanceModificationInstructionDto]
    ] = Field(
        None,
        alias='startInstructions',
        description='**Optional**. A JSON array of instructions that specify which activities to start the process instance at.\nIf this property is omitted, the process instance starts at its default blank start event.',
    )
    skip_custom_listeners: Optional[bool] = Field(
        None,
        alias='skipCustomListeners',
        description='Skip execution listener invocation for activities that are started or ended as part of this request.\n**Note**: This option is currently only respected when start instructions are submitted\nvia the `startInstructions` property.',
    )
    skip_io_mappings: Optional[bool] = Field(
        None,
        alias='skipIoMappings',
        description='Skip execution of\n[input/output variable mappings](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/#input-output-variable-mapping)\nfor activities that are started or ended as part of this request.\n**Note**: This option is currently only respected when start instructions are submitted\nvia the `startInstructions` property.',
    )
    with_variables_in_return: Optional[bool] = Field(
        None,
        alias='withVariablesInReturn',
        description='Indicates if the variables, which was used by the process instance during execution, should be returned.\nDefault value: `false`',
    )


class ProcessInstanceModificationDto(BaseModel):
    class Config:
        allow_population_by_field_name = True

    skip_custom_listeners: Optional[bool] = Field(
        None,
        alias='skipCustomListeners',
        description='Skip execution listener invocation for activities that are started or ended as part of this request.',
    )
    skip_io_mappings: Optional[bool] = Field(
        None,
        alias='skipIoMappings',
        description='Skip execution of [input/output variable mappings](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/#input-output-variable-mapping)\nfor activities that are started or ended as part of this request.',
    )
    instructions: Optional[Sequence[ProcessInstanceModificationInstructionDto]] = Field(
        None,
        description='JSON array of modification instructions. The instructions are executed in the order they are in.',
    )
    annotation: Optional[str] = Field(
        None,
        description='An arbitrary text annotation set by a user for auditing reasons.',
    )


ActivityInstanceDto.update_forward_refs()
HistoricProcessInstanceQueryDto.update_forward_refs()
ProcessInstanceQueryDto.update_forward_refs()
TaskQueryDto.update_forward_refs()
